---
title: 我的Python学习笔记
date: 2020-04-27 10:46:01
tags:
- Python
categories:
- Computer
---

[TOC]

## turtle画个图
```
r=25
area=3.1415926*r*r
print(area)`
print("{:.2f}F".format(area))
```
```
import turtle
turtle.pensize(20)
turtle.circle(10)
turtle.circle(40)
turtle.circle(80)
turtle.circle(160)
```

## 多行注释
"""
"""
## 单行注释 
\#

## 变量：
字母 数字 下划线 汉字（数字不能开头）
## 关键字：
33个

##  数据类型
### 整数类型

100111101

范围无限大
```
pow(x,y) 
```

### 浮点数类型

3.1415
```
0.1+0.3-->0.4
0.1+0.2-->0.3000000000000004存在不确定尾数

round(0.1+0.2,1)-->0.3

<a>e<b>  a*10^b
9.6e5-->960000.0
```


###  字符串
```
"请输入带有符号的温度值"
'C'
 ''' Python       语言''' 
单引号中可以表示双引号
双引号中可以表示单引号
```

###  切片

```
... -5 -4 -3 -2 -1  
    0 1 2 3 4 5 6...
  [start:end:step] 从start 提取到end - 1，每step 个字符提取一个
  [start:] 从start 提取到结尾
  [:end] 从开头提取到end - 1
```

###  操作函数

```
字符串操作函数
x+y 连接x,y
n*x  复制n次x
x in s  x是否是s的子串
```

### 字符串处理函数

```
len(x)
str(x)  str(1.23) -->"1.23"
chr(u)    Unicode->单字符
ord(x)    单字符 ->Unicode
```

###  字符串处理方法

```
str.lower() str.upper()
str.split()    "A B C".split(",") --> ["A","B","C"]
str.count(sub)  "a apple a day".count("a")-->4
str.replace(old,new)
str.center(width,"fillchar")
```

###  元组

```
用()或省或tuple()
一旦创建不能修改
```

```
creature = "cat","dog","monky","tiger"
print(creature)
color =(0x001100,"blue",creature)
print(color)
print(creature[::-1])
```

###  列表
```
用[]或list()
```

```
#数据保护

a=["cat","dog","tiger",1024]
b=tuple(a)
b
```

```
函数
ls.append(x)
ls.clear()
ls.copy
ls.insert(i,x)
ls.pop(i)
ls.remove(x)
ls.reverse()
```
######  字典

```
{键1:值1,键2:值2,键3:值3........}
dict()
d.keys()
d.values()
d.items()  返回所有键值对信息

d.get(k,default)
d.pop(k,default)
d.popitem()
d.clear()
len(d)
```

```
d ={"中国":"北京","美国":"华盛顿","法国":"巴黎"}
print(d)
print(d.keys())
print(d.values())
```

###  集合
```
A={"python",123,('python',123)}    #无序唯一
print(A)

B = set("pypy123")        #无序唯一
print(B)
```

###  集合运算
```
S|T  
S&T  
S-T  
S^T(补)  
S<=T S<T(子集)

S|=T 
S-=T 
S&=T 
S^=T(更新集合S)
```

```
S = {"p","y",123}
T = set("pypy123") 

print(S|T)
print(S&T)
print(S^T)
print(T-S)
print(S-T)
```     

### 集合函数

```
S.add(x)
S.discard(x)  移除，若不在，不报错
S.remove(x)    移除，若不在，报错
S.clear()
S.pop()           随机返回一个元素
S.copy()
len(S)
x in S
x not in S
set(x)        将x转为集合类型
```

### 集合去重

```
ls = ["p","p","y","y",123]
s = set(ls)
print(s)
```

## 运算符
### 算术运算符

    x/y  除
    x//y 整数除
    x%y 
    x**y  x的y次方
    xop=y x+=y x-=y x*=y x/=y
    
### 算数运算函数

    abs(x) 绝对值
    divmod(x,y)  (x//y,x%y)
    pow(x,y)    x**y
    pow(x,y,z)  (x**y)%z
    round(x,d)
    max(x1,x2,x3,x4)
    min(x1,x2,x3,x4)
    int(x) 
    float(x)     float(12) -->12.0  float("1.23") --> 1.23
    complex(x)   complex(4) --> 4+0j
    
      
###  关系运算符
```    
<
>
== 
!=
>=
<=
```

### 逻辑运算符

```
and 
or 
not
```
## 语句
###  赋值语句 

### 分支语句

```
if 条件：
    执行语句
elif 条件：
    执行语句
else:
    执行
    
简写：   <表达式1>if<条件>else<表达式2>
```

### 输入输出

```
变量 = input("something")
print("something")
 "{1}计算机{0}的CPU占用率为{2}%".format("2018-101-10","C",10)
 {序号 ： <填充> <对齐> <宽度> <,> <.精度> <类型>}
 
eval(字符串)
将字符串str当成有效的表达式来求值并返回计算结果
```

### 循环语句

#### for循环

```
for 变量 in 遍历结构:
        执行语句1
else:                  (一定执行)
    执行语句2 
   
 ```
 
 ```
for i in range(N):
    执行语句
for i in range(M,N,K):
    执行语句

for c in "python123":
    print(c,end=",")
    -->p,y,t,h,o,n,1,2,3,

for item in [123,"PY",456]:
    print(item,end=",")
    --->123,PY,456

for line in fi:
    print(line)
    --->
    优美胜于丑陋
    明了胜于隐晦
    简洁胜于复杂
    
```

#### while循环

```
while 条件表达式:
    执行语句1
else:                     (一定执行)
    执行语句2
```

```
a=3
while a>0:
    a=a-1
    print(a)

```

```
break 跳出循环
continue 跳出本次循环
```

## time库

```
import time
# 时间获取
print(time.gmtime()) #格林威治时间

#时间格式化
t=time.gmtime()
print(time.strftime("%Y-%m-%d %H:%M:%S",t))

## 程序计时
start=time.perf_counter()
end=time.perf_counter()
print(end-start)
"""
#调用一次perf_counter()，从计算机系统里随机选一个时间点A，
计算其距离当前时间点B1有多少秒。
当第二次调用该函数时，默认从第一次调用的时间点A算起，
距离当前时间点B2有多少秒。
两个函数取差，即实现从时间点B1到B2的计时功能。
"""

## 睡眠

def wait():
    time.sleep(3)
wait()

```

##  进度条

```
scale = 10
print("--执行开始--")
for i in range(scale+1):
    a = '*'*i
    b = '.'*(scale-i)
    c = (i/scale)*100
    print("{:^3.0f}%[{}-{}]".format(c,a,b))
    time.sleep(0.1)
print("--执行结束--")
```


##  单行动态刷新
```
# 默认end="\n"  光标退回到原来位置
for i in range(101):
    print("\r{:.3f}%".format(i),end="")   
    time.sleep(0.1)
```

##  进度条

```
str.center(width, fillchar)
返回一个在指定的宽度 width中 且居中的字符串，fillchar 为填充的字符，默认为空格
```

```
import time
scale = 50
print("执行开始".center(scale//2,"-"))  # 填充
start = time.perf_counter()
for i in range(scale+1):
    a = '*'*i
    b = '.'*(scale - i)
    c = (i/scale)*100
    dur = time.perf_counter()-start
    print("\r{:^3.0f}%[{}-{}]{:.2f}s".format(c,a,b,dur),end="") #默认end="\n"
    time.sleep(0.1)
print("\n"+"执行结束".center(scale//2,'-'))
```

##  random库

###  基本随机数函数

```
random.seed(10)
random.random()   0.0-1.0之间的随机小数
```

### 扩展随机数函数

```
random.randint(a,b)      a-b之间的随机整数
random.randrange(m,n,k)    m-n之间步长为k的随机整数
random.getrandbits(k)         kbit长的随机整数
```
```
random.uniform(a,b)            a-b之间的随机小数
random.choice(seq)             从seq中随机选择一个  
random.shuffle(seq)               将seq打乱
```

##  异常处理

```
try :
    语句1 
except:         (出错执行)
    语句2
else:            (正常执行)
    语句3
finally:          (一定会执行)
    语句4
```

##  函数

```
def 函数名(参数):
    函数体
    return 返回值
```

```
def getNum():      #获取用户不定长度的输入
    nums=[]
    iNumStr = input("请输入数字(回车退出)")
    while iNumStr != "":
        nums.append(eval(iNumStr))
        iNumStr = input("请输入数字(回车退出)")
    return nums

def mean(numbers):    #计算平均值
    s=0.0
    for num in numbers:
        s+=num
    return s/len(numbers)

def dev(numbers,mean):   #计算方差
    sdev = 0.0
    for num in numbers:
        sdev = sdev+(num-mean)**2
    return pow(sdev/(len(numbers)-1),0.5)

def median(numbers):     #计算中位数
    sorted(numbers)
    size = len(numbers)
    if size %2 ==0:
        med = (numbers[size//2-1]+numbers[size//2])/2
    else:
        med = numbers[size//2]
    return med

n = getNum()
m = mean(n)
print("平均值:{},方差:{:.2},中位数:{}".format(m,dev(n,m)),median(n))
```

##  文件操作

```
变量名 = open(文件名,打开方式)
变量名.close()
```

```
rt rb   以读模式打开，指针回到开头
r+      以读写模式打开，指针回到开头，文件不存在报错
wt wb   以写模式打开，指针回到开头
w+       以读写模式打开，指针回到开头，文件不存在新建
a       以写模式打开，指针在结尾，文件不存在新建
a+     以读写模式打开，指针在结尾，文件不存在新建
```

###  文件内容读取

```
<f>.read(size)    读全部内容，前size长度的
<f.>readline(size)  读一行内容，前size长度的
<f>.readlines(hint) 读所有行，以每行为元素形成列表，前hint行的
```

###  文件内容写入

```
<f>.write(s)
<f>.writelines(lines)
<f>.seek(offset) 0 -开头 1-当前位置 2-结尾
```

```
# 文本文件

tf = open("f.txt","rt")
print(tf.readline())
tf.close()
```

```
#二进制文件

bf = open("f.txt","rb")
print(bf.readline())
bf.close()
```

```
fo = open("output.txt","w+")
ls =["中国","法国","美国"]
fo.writelines(ls)        # 可以写进去
fo.seek(0)               #指针回到开头，打印出来
for line in fo:
    print(line)
fo.close()
```

## yield用法

先把yield看成return
但return返回一个值后，程序结束

```
def fun():
    print("开始...")
    while True:
        res = yield 4
        print("res:",res)
g = fun()
print(next(g))
print("*"*20)
print(next(g))
```


### 解释
1. 程序开始执行以后，因为fun函数中有yield关键字，所以fun函数并不会真的执行，
而是先得到一个生成器g(相当于一个对象)
2. 直到调用next方法，fun函数正式开始执行，先执行fun函数中的print方法，然后进入while循环
3. 程序遇到yield关键字，然后把yield想象成return,return了一个4之后，程序停止，
并没有执行赋值给res操作，此时next(g)语句执行完成，
所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果
4. 程序执行，输出20个星 
5. 又开始执行下面的print(next(g)),这个时候是从刚才那个next程序停止的地方开始执行的，
也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的
（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），
所以这个时候res赋值是None,所以接着下面的输出就是res:None,
6. 程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，
print函数输出的4就是这次return出的4

7. 带yield的函数是一个生成器，而不是一个函数了，
这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，
这一次的next开始的地方是接着上一次的next停止的地方执行的，

```
def fun():
    print("开始...")
    while True:
        res = yield 4
        print("res:",res)
g = fun()
print(next(g))
print("*"*20)
print(g.send(7))
```


send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，
下次执行的时候只好继续执行赋值操作，只好赋值为None了，
而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,
然后执行next的作用，遇见下一回的yield，return出结果后结束
