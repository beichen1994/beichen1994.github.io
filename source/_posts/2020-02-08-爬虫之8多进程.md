---
title: 爬虫之8多进程
date: 2020-02-08 22:52:31
tags:
- 爬虫
categories: 
- Computer
---

# 多进程

Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次， 但是fork()调用一次，返回两次



因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回 子进程永远返回0，而父进程返回子进程的ID



这样做的理由是，一个父进程可以fork出很多子进程， 所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。



有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务


## multiprocessing模块
提供了一个Process类来代表一个进程对象
```
from multiprocessing import Process
import os

#子进程要执行的代码
def proc(name):
    print("运行子进程 %s为(%s)" %(name,os.getpid()))

if __name__ =="__main__":
    print("运行父进程 %s" % os.getpid())
    p = Process(target=proc, args=('test',))
    print("子进程将开始")
    p.start()
    p.join()
    print("子进程结束")
```
 
 ##  pool
 进程池的方式批量创建子进程
 ```
 from multiprocessing import Pool

# 创建进程池
pool = Pool()

# 第一个参数是函数，第二个参数是一个迭代器，将迭代器中的数字作为参数依次传入函数中
pool.map(main, [i*10 for i in range(10)])
```

```
from multiprocessing import Pool
import os
import time
import random

def long_time_task(name):
    print("运行任务%s (%s)" %(name,os.getpid()))
    start_time = time.time()
    time.sleep(random.random()*3)
    end_time = time.time()
    print("任务%s运行 %f秒" %(name,(end_time-start_time)))

if __name__ =="__main__":
          p = Pool(4)
        
          for i in range(5):
              p.apply_async(func=long_time_task,args=(i,))
            
          print("等待所有的子进程结束")
          p.close()
          p.join()
          print("所有的子进程结束")
```    
