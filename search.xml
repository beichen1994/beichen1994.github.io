<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>爬虫管理平台使用</title>
      <link href="/2020/05/06/pa-chong-guan-li-ping-tai-shi-yong/"/>
      <url>/2020/05/06/pa-chong-guan-li-ping-tai-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>#爬虫管理平台</p><p>我目前的爬虫都是一个个单独的程序文件，顶多同步到github，并没有一个统一的可视化管理平台。之前看到过崔大的<a href="https://github.com/Gerapy/Gerapy" target="_blank" rel="noopener">Gerapy</a>，但没有使用下来。</p><p>最近在github发现了一个爬虫管理平台，名为<a href="https://github.com/crawlab-team/crawlab" target="_blank" rel="noopener">Crawlab</a>，目前该平台还在不断地完善中，以后有望会进行商用，我目前已经进行了安装，看下效果。</p><p>Crawlab提供了docker的安装方式，安装简单快捷。启动后会同时开启四个容器，分别是Crawlab的master容器，worker容器，mongodb容器以及redis容器。但是很可惜，我之前并没有使用过mongodb，对于redis也是一知半解，所以用起来并不顺手。哎，看来还是要学习一下mongodb和redis了。真是学不完的知识啊！</p><p>Crawlab在启动后，输入(<a href="http://localhost:8080)，" target="_blank" rel="noopener">http://localhost:8080)，</a><br>即可打开管理界面。参照Crawlab的文档，即可使用。我目前按照文档的说明，在conda中安装了crawlab-sdk，可以通过命令行操作该爬虫管理平台。</p><pre><code>登录获取 Tokencrawlab login -u admin -a http://localhost:8080/api上传指定目录并附带爬虫名称、显示名称、结果集等信息crawlab upload \    -d /path/to/spider \ # 爬虫目录    -n &lt;spider_name&gt; \ # 爬虫名称    -N &lt;display_name&gt; \ # 显示名称    -m &lt;execute_command&gt; \ # 执行命令    -c &lt;result_collection&gt; # 结果集查看节点列表crawlab nodes查看爬虫列表crawlab spiders查看任务列表crawlab tasks查看定时任务列表crawlab schedules</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新拾起我的Java</title>
      <link href="/2020/05/05/chong-xin-shi-qi-wo-de-java/"/>
      <url>/2020/05/05/chong-xin-shi-qi-wo-de-java/</url>
      
        <content type="html"><![CDATA[<h2 id="对于Java，我想说的一些话"><a href="#对于Java，我想说的一些话" class="headerlink" title="对于Java，我想说的一些话"></a>对于Java，我想说的一些话</h2><p>&ensp;&ensp;说起Java，我对其的感情还是比较复杂。这门语言应该是我主动自学的第一门编程语言。由于在本科阶段的学习中，有C语言和C++语言等课程，所以对编程还算是比较了解。一开始是从网上找的马士兵老师的Java视频进行自学，马士兵老师的教学视频质量是真的好，在学习过程中我也慢慢的喜欢上了Java。但是由于我没有良好的做笔记的习惯，所以我虽然花了很多的时间，但是我对Java的学习就像狗熊掰棒子一样，学了后面的忘了前面的，同时没有正向的反馈和可视化的学习成果，我的Java一直没有突破瓶颈期。以至于后来对于Java，我竟提不起丝毫的兴趣。<br>&ensp;&ensp;而我之所以要重新开始拾起Java，很大一方面原因是我优化了我的学习过程和学习环境。我现在可以使用docker来运行Java环境，省去了麻烦的配置过程。我可以使用vscode或者vim来进行编程，同时使用git管理并同步我的代码，不至于我的代码会杂乱无章。我还可以随时在博客中记录笔记。这些都将极大的提升我的学习效率和学习效果。<br>&ensp;&ensp;虽然我以后可能还是不会经常使用Java，但毕竟我对Java也倾注了不少的心血，我不希望我的努力白废掉，至少可以对他人能够有所帮助。</p><p>##目前打算使用的环境</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的docker使用2</title>
      <link href="/2020/05/05/wo-de-docker-shi-yong-2/"/>
      <url>/2020/05/05/wo-de-docker-shi-yong-2/</url>
      
        <content type="html"><![CDATA[<h1 id="我想说的话"><a href="#我想说的话" class="headerlink" title="我想说的话"></a>我想说的话</h1><p>虽然我以后的工作中几乎没有用到docker的可能性，但我还是想用docker，因为我觉得这的确是一个非常好的工具，让每一种环境都隔离起来，不会造成互相污染，同时可打包，方便分享和传播，很得我心！</p><p>我目前也在不断地学习docker，我找到了一个非常好的网站<a href="https://labs.play-with-docker.com/" target="_blank" rel="noopener">play with docker</a>，在这个平台中我们可以练习使用docker。</p><p>对于docker的整个生态，可以用下面这张图来形容<img src="https://s1.ax1x.com/2020/05/05/YknFCF.png" alt="YknFCF.png"></p><p>如果要问我要用什么来编写Dockerfile,那我会毫不犹豫的说必须是VSCode！这个编辑器真的是每次都会带给我惊喜。在我要学习编写Dockerfile时，发现VSCode对docker的兼容是如此的完美，我们可以愉快的使用VSCode管理docker镜像、容器以及创造我们自己的镜像和容器。</p><p>对于Dockerfile我看过一些教学视频，有个视频好几个小时，有的视频短短十几分钟，带给我的感受就是只听课，没有实战练习，还是无法真正体会docker的精髓，这么多命令学习起来还是比较枯燥的。</p><p>这篇文章我会记录我的Dockerfile的笔记</p><h1 id="Dockerfile学习"><a href="#Dockerfile学习" class="headerlink" title="Dockerfile学习"></a>Dockerfile学习</h1><hr><p>FROM<br>WORKDIR<br>COPY<br>RUN<br>CMD</p><hr><p>EXPOSE<br>VOLUME</p><hr><p>ENV<br>ARG</p>]]></content>
      
      
      <categories>
          
          <category> 神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的可视化笔记2</title>
      <link href="/2020/04/30/wo-de-ke-shi-hua-bi-ji-2/"/>
      <url>/2020/04/30/wo-de-ke-shi-hua-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="统计图"><a href="#统计图" class="headerlink" title="统计图"></a>统计图</h1><p>持续补充</p><h2 id="单变量图"><a href="#单变量图" class="headerlink" title="单变量图"></a>单变量图</h2><h3 id="分类变量"><a href="#分类变量" class="headerlink" title="分类变量"></a>分类变量</h3><ul><li><p>简单条图<br>  matplotlib<br>  DataFrame.plot.bar()</p><p>  seaborn<br>  seaborn.barplot(</p><pre><code>  1. x:绘图中所使用的分类  2. y:连续变量  3. hue:颜色分组变量名  4. data:数据框名称  5. order:确定分类变量的出现与顺序  6. hue_order:  7. orient:  8. saturation=0.75: 直条颜色的饱和度</code></pre><p>  )<br>  返回Axes对象</p></li><li><p>点图</p></li><li><p>饼图</p><p>  DataFrame.plot.pie()<br>  matplotlib.pyplot.pie()<br>  plt.pie()</p></li><li><p>百分比图</p></li><li><p>Pareto图</p></li><li><p>圆环图</p></li><li><p>气泡图</p></li></ul><h3 id="数值变量-连续变量"><a href="#数值变量-连续变量" class="headerlink" title="数值变量(连续变量)"></a>数值变量(连续变量)</h3><ul><li><p>条带图</p></li><li><p>地毯图</p></li><li><p>直方图</p></li><li><p>茎叶图</p></li><li><p>箱图</p></li><li><p>增强箱图</p></li><li><p>KDE图(核密度估计)</p></li><li><p>提琴图</p></li><li><p>P-P图</p></li><li><p>Q-Q图</p></li></ul><h2 id="双变量图"><a href="#双变量图" class="headerlink" title="双变量图"></a>双变量图</h2><ul><li><p>分类变量vs分类变量<br>  分组图<br>  行面板图<br>  列面板图<br>  分组条图<br>  堆积条图<br>  百分条图(马赛克图)<br>  树状图<br>  圆环图</p></li><li><p>数值变量vs分类变量<br>  分组条带图<br>  分组箱图<br>  分组提琴图<br>  同类图形组合<br>  简单条图<br>  面积图<br>  线图</p></li><li><p>数值变量vs数值变量<br>  散点图<br>  Hexplot/Sunflower图<br>  KDE图/等高线图</p></li></ul><h2 id="多变量图"><a href="#多变量图" class="headerlink" title="多变量图"></a>多变量图</h2><ul><li>双变量图+更多的分类变量<br>  采用图例对二维图进行扩充<br>  颜色图例<br>  线宽<br>  线形/散点<br>  线填充图案</li></ul><p>行面板图/列面板图组合</p><p>将多个连续变量看作一个变量，虚拟一个新的分组变量用于区分<br>双轴图</p><p>图形矩阵：主对角线呈现单变量分布，非主对角线呈现联合分布</p><p>统计地图</p><p>甘特图<br>表巴图<br>人口金字塔、漏斗图、K线图、瀑布图</p><p>词云<br>热图</p><p>雷达图<br>凹凸图</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的stata学习</title>
      <link href="/2020/04/29/wo-de-stata-xue-xi/"/>
      <url>/2020/04/29/wo-de-stata-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>整理一下stata的笔记</p><pre class="line-numbers language-stata"><code class="language-stata">use E:\grilic_small.dta,clear打开dta数据文件clear清空内存中的数据described审查数据list s lnw查看变量s和lnw的具体数据list s lnw in 1/5查看变量s和lnw的1-5的数据list s lnw if s>=16查看s>=16的变量s和lnw的数据set more off设置连续滚屏显示命令运行结果drop if s>=16删除满足s>=16条件的观测值keep if s>=16只想保留满足s>=16条件的观测值sort slist将数据变量s的升序排列gsort -slist将变量s的降序排列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><pre class="line-numbers language-stata"><code class="language-stata">histogram s, width(1)  frequency直方图，选择项width(1)表示组宽设置为1，选择项frequency表示纵坐标设置为频数help histogram查看histogram帮助文件scatter lnw s散点图gen n= _n_n表示第n个观测值，变量n赋值为_nscatter lnw s, mlabel(n)mlabel(n)表示以变量n作为marklabel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h2><pre class="line-numbers language-stata"><code class="language-stata">summarize ssum s查看变量s的统计特征tabulate stab s查看变量s的经验累积分布函数(empirical cumulative distribution function)pwcorr lnw s expr, sig star(.05)显示工资对数、教育年限、工龄之间的相关系数pwcorr表示pairwise correlation（两两相关）sig表示相关系数的显著性水平(即p值，列在相关系数的下方)star(.05)表示所有显著性水平小于或等于5%的相关系数打成星号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="生成新变量"><a href="#生成新变量" class="headerlink" title="生成新变量"></a>生成新变量</h2><pre class="line-numbers language-stata"><code class="language-stata">generate lns=log(s)gen lns = log(s)定义教育年限的对数gen s2 = s^2定义s的平方项gen exprs = s* expr生成s和expr的互动项(interaction term)gen w =exp(lnw)根据工资对数lnw计算工资水平wgen college=(s>=16)虚拟变量/哑变量(只能取值0、1)college = 1  ;s>=16college =  0 ;s<16rename colleg college重命名变量replace college=(s>=15)重新设置变量collegedrop s*删除所有以s开头的变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><pre class="line-numbers language-stata"><code class="language-stata">display log(2)dis log(2)dis 2^0.5log using 20191115在当前路径生成一个名为 20191115的日志文件log off暂时关闭日志log on恢复使用日志log close彻底退出日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令更新"><a href="#命令更新" class="headerlink" title="命令更新"></a>命令更新</h2><pre class="line-numbers language-stata"><code class="language-stata">sysdir显示stata~~~的系统路径search keywordfindit keyword搜索某个命令/方法ssc install newcommand从ssc下载stata程序，自动进行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的可视化笔记1</title>
      <link href="/2020/04/29/wo-de-ke-shi-hua-bi-ji-1/"/>
      <url>/2020/04/29/wo-de-ke-shi-hua-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<p>Python中的matplotlib库是一个强大的可视化工具，本篇将持续对matplotlib以及相关的库学习做一些笔记。</p><h2 id="导入绘图环境"><a href="#导入绘图环境" class="headerlink" title="导入绘图环境"></a>导入绘图环境</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltplt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.family'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'SimHei'</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'中文字体'</span><span class="token punctuation">)</span><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> snssns<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#加载seaborn默认的格式设定</span><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> os<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.jianshu.com/p/d20a0971756b" target="_blank" rel="noopener">linux中matplotlib无法显示中文解决办法</a></p><h2 id="图形对象"><a href="#图形对象" class="headerlink" title="图形对象"></a>图形对象</h2><p><img src="https://s1.ax1x.com/2020/04/29/JTDsv6.png" alt="JTDsv6.png"></p><h3 id="创建Figure对象"><a href="#创建Figure对象" class="headerlink" title="创建Figure对象"></a>创建Figure对象</h3><p>matplotlib首先创建fig对象，然后基于fig对象绘图</p><pre class="line-numbers language-python"><code class="language-python">matploblib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span> num<span class="token punctuation">:</span> 图形ID<span class="token number">2</span><span class="token punctuation">.</span> figsize：图形长宽<span class="token number">3</span><span class="token punctuation">.</span> dpi：图形分辨率<span class="token number">4</span><span class="token punctuation">.</span> facecolor：背景色<span class="token number">5</span><span class="token punctuation">.</span> edgecolor：边框色<span class="token number">6</span><span class="token punctuation">.</span> frameon<span class="token operator">=</span><span class="token boolean">True</span>：是否绘制图形外框架<span class="token number">7</span><span class="token punctuation">.</span> FigureClass：使用自定义的matploblib<span class="token punctuation">.</span>figure<span class="token punctuation">.</span>Figure类<span class="token number">8</span><span class="token punctuation">.</span> clear<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">:</span>是否清除原有的Fig对象<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调用plot"><a href="#调用plot" class="headerlink" title="调用plot()"></a>调用plot()</h3><p>plot()在Axes(子图)上绘图，如果没有指定Axes对象，则会创建一个布满整个Figure对象的Axes对象</p><pre class="line-numbers language-python"><code class="language-python">matploblib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span> x<span class="token punctuation">:</span>X轴对应数据，缺省为<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>N<span class="token number">-1</span><span class="token punctuation">]</span><span class="token number">2</span><span class="token punctuation">.</span> y<span class="token punctuation">:</span>Y轴对应数据<span class="token number">3</span><span class="token punctuation">.</span> data<span class="token punctuation">:</span>列变量所对应的数据框名称<span class="token number">4</span><span class="token punctuation">.</span> fmt<span class="token punctuation">:</span><span class="token punctuation">[</span>color<span class="token punctuation">]</span><span class="token punctuation">[</span>marker<span class="token punctuation">]</span><span class="token punctuation">[</span>line<span class="token punctuation">]</span>的格式<span class="token number">5</span><span class="token punctuation">.</span> label<span class="token punctuation">:</span>曲线的标签名，可以用latex公式<span class="token number">6</span><span class="token punctuation">.</span> color<span class="token punctuation">:</span>曲线的颜色<span class="token number">7</span><span class="token punctuation">.</span> linewidth<span class="token punctuation">:</span>曲线宽度<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span>color<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'b'</span> <span class="token string">'g'</span> <span class="token string">'r'</span> <span class="token string">'c'</span> <span class="token string">'m'</span> <span class="token string">'y'</span> <span class="token string">'k'</span> <span class="token string">'w'</span><span class="token punctuation">[</span>marker<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'.'</span> <span class="token string">','</span> <span class="token string">'o'</span> <span class="token string">'v'</span> <span class="token string">'1'</span> <span class="token string">'2'</span> <span class="token string">'3'</span> <span class="token string">'4'</span><span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token string">'--'</span> <span class="token string">'-.'</span> <span class="token string">':'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设定当前Axes对象的属性</p><pre class="line-numbers language-python"><code class="language-python">xlim<span class="token operator">/</span>ylim：设置X轴Y轴的刻度范围xlabel<span class="token operator">/</span>ylabel<span class="token punctuation">:</span>X轴Y轴的标题文字clabel：为轮廓线设置标题文字title：子图的标题legend：显示图示annotate：绘制图形标注axhspan：回执垂直和水平色块fill：填充区域<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="柱状-简单条图"><a href="#柱状-简单条图" class="headerlink" title="柱状(简单条图)"></a>柱状(简单条图)</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>bar<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>barh<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="水平直方图"><a href="#水平直方图" class="headerlink" title="水平直方图"></a>水平直方图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>broken_barh<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="柱形图"><a href="#柱形图" class="headerlink" title="柱形图"></a>柱形图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>hist<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="水平柱状图"><a href="#水平柱状图" class="headerlink" title="水平柱状图"></a>水平柱状图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>hist2d<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>pie<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="等高线图"><a href="#等高线图" class="headerlink" title="等高线图"></a>等高线图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>contour<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="误差线"><a href="#误差线" class="headerlink" title="误差线"></a>误差线</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>errorbar<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="六边形图案"><a href="#六边形图案" class="headerlink" title="六边形图案"></a>六边形图案</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>hexbin<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="以图形显示"><a href="#以图形显示" class="headerlink" title="以图形显示"></a>以图形显示</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="量场图"><a href="#量场图" class="headerlink" title="量场图"></a>量场图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>quivet<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="电子波谱图"><a href="#电子波谱图" class="headerlink" title="电子波谱图"></a>电子波谱图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>angle_spectrum<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="光谱图"><a href="#光谱图" class="headerlink" title="光谱图"></a>光谱图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>specgram<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="绘制子图"><a href="#绘制子图" class="headerlink" title="绘制子图"></a>绘制子图</h3><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="显示图形、保存图形"><a href="#显示图形、保存图形" class="headerlink" title="显示图形、保存图形"></a>显示图形、保存图形</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">%</span>matplotlib qt5plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span>matplotlib inline<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'test.png'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的git笔记</title>
      <link href="/2020/04/27/wo-de-git-bi-ji/"/>
      <url>/2020/04/27/wo-de-git-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>一开始我对git还是比较抵触，学习成本较高，因为不懂所以不知其便利。但终究还是没有忍住git对我的诱惑，便尝试了起来。我是按照<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的git课程</a>进行学习的。目前我也只能算是入门，还远没有达到精通的地步。现将git的学习笔记进行一下整理。</p><p><img src="https://s1.ax1x.com/2020/04/27/Jf31Gq.jpg" alt="Jf31Gq.jpg"></p><ul><li>git初始配置</li></ul><pre><code>ssh -T git@github.comgit remote -vgit config --global user.name &quot;beichen1994&quot;git config --global user.email &quot;1768229565@qq.com&quot;git config --listssh-keygen</code></pre><ul><li><p>创建git仓库</p><pre><code>mkdir learngitcd learngitgit init</code></pre></li><li><p>将修改添加到暂存区，提交到Master分支</p></li></ul><pre><code>编写 file1.txt file2.txt file3.txtgit add file1.txtgit add file2.txt file3.txtgit commit -m &quot;update&quot;</code></pre><pre><code>继续修改 file1.txtgit status 查看仓库状态 git diff file1.txt 查看修改内容git add file1.txtgit commit -m &quot;update&quot;git status 查看仓库状态</code></pre><ul><li>版本回退</li></ul><pre><code>继续修改file1.txtgit add file1.txtgit commit -m &quot;udpate&quot;git log查看提交过程，目前file1.txt一共进行了三次提交，也就是有三个版本git reset --hard head^ 将file1.txt更改为第二次提交，顺便将工作区的文件进行了更新git log查看提交过程，目前只显示两次提交git reflog 查看所有提交历史，便于使用版本号进行resetgit reset --hard 1094 将file1.txt更改为1094号提交，顺便将工作区的文件进行了更新</code></pre><ul><li>撤销修改</li></ul><pre><code>git reset HEAD readme.txt如果file1.txt已经添加到暂存区，现在撤销暂存区的修改</code></pre><pre><code>git checkout -- file1.txt如果文件修改出问题，用版本库，即暂存区或者分支上的版本替换工作区的版本(撤销file1.txt在工作区的修改)</code></pre><ul><li>文件删除</li></ul><pre><code>先将工作区的file2.txt删除git rm file2.txt 将版本库中的文件删除git commit -m &quot;udpate&quot;</code></pre><pre><code>git checkout -- file2.txt如果文件删错了，用版本库中的文件替换工作区</code></pre><p>关联远程仓库</p><pre><code>git remote add origin git@github.com:beichen1994/Repo.gitgit push -u origin mastergit clone git@github.com:beichen1994/gitskills.git克隆到本地库</code></pre><p>使用git提交的时候出现The file will have its original line endings in your working directory.错误</p><p>1 git rm -r -f –cached ./ (删除缓存)<br>2 git add . （添加该目录下所有文件）<br>3 git push -u origin master （这时候提交就没问题了）</p><ul><li>分支管理</li></ul><pre><code>git branch dev创建dev分支git checkout dev然后切换到dev分支git branch查看所有分支修改file1.txtgit add file1.txtgit commit -m &quot;update&quot;git checkout master切换回master分支，发现file1.txt中的修改不见了git merge dev合并dev分支到当前分支 (master)git branch -d dev删除dev分支</code></pre><ul><li>解决冲突</li></ul><pre><code>git branch feature1git checkout feature1继续修改file1.txtgit add file1.txtgit commit -m &quot;update&quot;在feature1分支上提交修改git checkout master切换到master分支继续修改file1.txtgit add file1.txtgit commit -m &quot;update&quot;在master分支上提交git merge feature1两个分支上的file1.txt出现冲突将master分支上的file1.txt文件修改一下git add file1.txtgit commit -m &quot;update&quot;在master分支上继续提交git branch -d feature1删除feature1分支</code></pre><p>整个过程如下所示<br><img src="https://s1.ax1x.com/2020/04/27/JfyUgS.png" alt="JfyUgS.png"><br><img src="https://s1.ax1x.com/2020/04/27/JfyN38.png" alt="JfyN38.png"><br><img src="https://s1.ax1x.com/2020/04/27/Jfyt9f.png" alt="Jfyt9f.png"><br><img src="https://s1.ax1x.com/2020/04/27/JfylBd.png" alt="JfylBd.png"><br><img src="https://s1.ax1x.com/2020/04/27/Jfy1HA.png" alt="Jfy1HA.png"><br><img src="https://s1.ax1x.com/2020/04/27/Jfy8AI.png" alt="Jfy8AI.png"><br><img src="https://s1.ax1x.com/2020/04/27/JfyGNt.png" alt="JfyGNt.png"><br><img src="https://s1.ax1x.com/2020/04/27/JfyJ4P.png" alt="JfyJ4P.png"></p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的正则表达式总结</title>
      <link href="/2020/04/27/wo-de-zheng-ze-biao-da-shi-zong-jie/"/>
      <url>/2020/04/27/wo-de-zheng-ze-biao-da-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>正则表达式用途非常广泛，唯有熟才能生巧。我只是偶尔会用到，所以在这里学习并记录一下。以备翻阅。</p><hr><ul><li>主料</li></ul><pre><code>.匹配所有出现的单个字符（断行不行）..匹配所有出现的双字符...匹配所有出现的三字符....匹配所有出现的四字符\w匹配所有出现的0-9、大小写字母、下划线\W倒置\w\d匹配所有出现的单个数字\d\.\d可以匹配3.1\D倒置\d\s匹配所有出现的空格、tab、断行\S倒置\s[选择范围]匹配字符串中所有出现的该范围的任意字符组合[abc]匹配字符串所有出现的abc、所有出现的a、所有出现的b、所有出现的c、所有出现的ab、所有出现的bc、所有出现的ac、[a-z]匹配字符串中所有出现的a-z的所有组合[A-Z]匹配字符串中所有出现的A-Z的所有组合[0-9]匹配字符串中所有出现的0-9的所有组合\b词的边界</code></pre><hr><ul><li>配料</li></ul><pre><code>[范围]+范围内的任意字符组合重复一次或多次[yY][oO]+比如可以匹配yo、yoooo、Yo、YoOo[范围]*范围内的任意字符组合可选(重复0次或多次)[yY][oO]+[!~\.]*可以匹配yo、yooo、Yo、yo！、yo！！、yo[范围]？范围内的任意字符组合可选(重复0次或1次)[yY][oO]+p?[!~.]*可以匹配 yop!!、yooop、Yoop、yo、yooooo、yooo~~~[范围]{a,b}范围内的任意字符组合重复a-b次yo{2,}可以匹配yoo、yooo、yoooo（o至少出现2次）</code></pre><hr><pre><code>yo{0,1} 等同于 yo？yo{0,} 等同于 yo*yo{1,} 等同于 yo+.+飞飞, .+追追(.+)飞飞, (.+)追追李全单飞飞，王花花追追匹配到两组，一组是李全单，一组是王花花</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Python学习笔记</title>
      <link href="/2020/04/27/wo-de-python-xue-xi-bi-ji/"/>
      <url>/2020/04/27/wo-de-python-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="turtle画个图"><a href="#turtle画个图" class="headerlink" title="turtle画个图"></a>turtle画个图</h2><pre><code>r=25area=3.1415926*r*rprint(area)`print(&quot;{:.2f}F&quot;.format(area))</code></pre><pre><code>import turtleturtle.pensize(20)turtle.circle(10)turtle.circle(40)turtle.circle(80)turtle.circle(160)</code></pre><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>“””<br>“””</p><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>#</p><h2 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h2><p>字母 数字 下划线 汉字（数字不能开头）</p><h2 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h2><p>33个</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>100111101</p><p>范围无限大</p><pre><code>pow(x,y) </code></pre><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p>3.1415</p><pre><code>0.1+0.3--&gt;0.40.1+0.2--&gt;0.3000000000000004存在不确定尾数round(0.1+0.2,1)--&gt;0.3&lt;a&gt;e&lt;b&gt;  a*10^b9.6e5--&gt;960000.0</code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code>&quot;请输入带有符号的温度值&quot;&#39;C&#39; &#39;&#39;&#39; Python       语言&#39;&#39;&#39; 单引号中可以表示双引号双引号中可以表示单引号</code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><pre><code>... -5 -4 -3 -2 -1      0 1 2 3 4 5 6...  [start:end:step] 从start 提取到end - 1，每step 个字符提取一个  [start:] 从start 提取到结尾  [:end] 从开头提取到end - 1</code></pre><h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><pre><code>字符串操作函数x+y 连接x,yn*x  复制n次xx in s  x是否是s的子串</code></pre><h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><pre><code>len(x)str(x)  str(1.23) --&gt;&quot;1.23&quot;chr(u)    Unicode-&gt;单字符ord(x)    单字符 -&gt;Unicode</code></pre><h3 id="字符串处理方法"><a href="#字符串处理方法" class="headerlink" title="字符串处理方法"></a>字符串处理方法</h3><pre><code>str.lower() str.upper()str.split()    &quot;A B C&quot;.split(&quot;,&quot;) --&gt; [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]str.count(sub)  &quot;a apple a day&quot;.count(&quot;a&quot;)--&gt;4str.replace(old,new)str.center(width,&quot;fillchar&quot;)</code></pre><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><pre><code>用()或省或tuple()一旦创建不能修改</code></pre><pre><code>creature = &quot;cat&quot;,&quot;dog&quot;,&quot;monky&quot;,&quot;tiger&quot;print(creature)color =(0x001100,&quot;blue&quot;,creature)print(color)print(creature[::-1])</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>用[]或list()</code></pre><pre><code>#数据保护a=[&quot;cat&quot;,&quot;dog&quot;,&quot;tiger&quot;,1024]b=tuple(a)b</code></pre><pre><code>函数ls.append(x)ls.clear()ls.copyls.insert(i,x)ls.pop(i)ls.remove(x)ls.reverse()</code></pre><h6 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h6><pre><code>{键1:值1,键2:值2,键3:值3........}dict()d.keys()d.values()d.items()  返回所有键值对信息d.get(k,default)d.pop(k,default)d.popitem()d.clear()len(d)</code></pre><pre><code>d ={&quot;中国&quot;:&quot;北京&quot;,&quot;美国&quot;:&quot;华盛顿&quot;,&quot;法国&quot;:&quot;巴黎&quot;}print(d)print(d.keys())print(d.values())</code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><pre><code>A={&quot;python&quot;,123,(&#39;python&#39;,123)}    #无序唯一print(A)B = set(&quot;pypy123&quot;)        #无序唯一print(B)</code></pre><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><pre><code>S|T  S&amp;T  S-T  S^T(补)  S&lt;=T S&lt;T(子集)S|=T S-=T S&amp;=T S^=T(更新集合S)</code></pre><pre><code>S = {&quot;p&quot;,&quot;y&quot;,123}T = set(&quot;pypy123&quot;) print(S|T)print(S&amp;T)print(S^T)print(T-S)print(S-T)</code></pre><h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><pre><code>S.add(x)S.discard(x)  移除，若不在，不报错S.remove(x)    移除，若不在，报错S.clear()S.pop()           随机返回一个元素S.copy()len(S)x in Sx not in Sset(x)        将x转为集合类型</code></pre><h3 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h3><pre><code>ls = [&quot;p&quot;,&quot;p&quot;,&quot;y&quot;,&quot;y&quot;,123]s = set(ls)print(s)</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><pre><code>x/y  除x//y 整数除x%y x**y  x的y次方xop=y x+=y x-=y x*=y x/=y</code></pre><h3 id="算数运算函数"><a href="#算数运算函数" class="headerlink" title="算数运算函数"></a>算数运算函数</h3><pre><code>abs(x) 绝对值divmod(x,y)  (x//y,x%y)pow(x,y)    x**ypow(x,y,z)  (x**y)%zround(x,d)max(x1,x2,x3,x4)min(x1,x2,x3,x4)int(x) float(x)     float(12) --&gt;12.0  float(&quot;1.23&quot;) --&gt; 1.23complex(x)   complex(4) --&gt; 4+0j</code></pre><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><pre><code>&lt;&gt;== !=&gt;=&lt;=</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><pre><code>and or not</code></pre><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><pre><code>if 条件：    执行语句elif 条件：    执行语句else:    执行简写：   &lt;表达式1&gt;if&lt;条件&gt;else&lt;表达式2&gt;</code></pre><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><pre><code>变量 = input(&quot;something&quot;)print(&quot;something&quot;) &quot;{1}计算机{0}的CPU占用率为{2}%&quot;.format(&quot;2018-101-10&quot;,&quot;C&quot;,10) {序号 ： &lt;填充&gt; &lt;对齐&gt; &lt;宽度&gt; &lt;,&gt; &lt;.精度&gt; &lt;类型&gt;}eval(字符串)将字符串str当成有效的表达式来求值并返回计算结果</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><pre><code>for 变量 in 遍历结构:        执行语句1else:                  (一定执行)    执行语句2 </code></pre><pre><code>for i in range(N):    执行语句for i in range(M,N,K):    执行语句for c in &quot;python123&quot;:    print(c,end=&quot;,&quot;)    --&gt;p,y,t,h,o,n,1,2,3,for item in [123,&quot;PY&quot;,456]:    print(item,end=&quot;,&quot;)    ---&gt;123,PY,456for line in fi:    print(line)    ---&gt;    优美胜于丑陋    明了胜于隐晦    简洁胜于复杂</code></pre><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><pre><code>while 条件表达式:    执行语句1else:                     (一定执行)    执行语句2</code></pre><pre><code>a=3while a&gt;0:    a=a-1    print(a)</code></pre><pre><code>break 跳出循环continue 跳出本次循环</code></pre><h2 id="time库"><a href="#time库" class="headerlink" title="time库"></a>time库</h2><pre><code>import time# 时间获取print(time.gmtime()) #格林威治时间#时间格式化t=time.gmtime()print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,t))## 程序计时start=time.perf_counter()end=time.perf_counter()print(end-start)&quot;&quot;&quot;#调用一次perf_counter()，从计算机系统里随机选一个时间点A，计算其距离当前时间点B1有多少秒。当第二次调用该函数时，默认从第一次调用的时间点A算起，距离当前时间点B2有多少秒。两个函数取差，即实现从时间点B1到B2的计时功能。&quot;&quot;&quot;## 睡眠def wait():    time.sleep(3)wait()</code></pre><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><pre><code>scale = 10print(&quot;--执行开始--&quot;)for i in range(scale+1):    a = &#39;*&#39;*i    b = &#39;.&#39;*(scale-i)    c = (i/scale)*100    print(&quot;{:^3.0f}%[{}-{}]&quot;.format(c,a,b))    time.sleep(0.1)print(&quot;--执行结束--&quot;)</code></pre><h2 id="单行动态刷新"><a href="#单行动态刷新" class="headerlink" title="单行动态刷新"></a>单行动态刷新</h2><pre><code># 默认end=&quot;\n&quot;  光标退回到原来位置for i in range(101):    print(&quot;\r{:.3f}%&quot;.format(i),end=&quot;&quot;)       time.sleep(0.1)</code></pre><h2 id="进度条-1"><a href="#进度条-1" class="headerlink" title="进度条"></a>进度条</h2><pre><code>str.center(width, fillchar)返回一个在指定的宽度 width中 且居中的字符串，fillchar 为填充的字符，默认为空格</code></pre><pre><code>import timescale = 50print(&quot;执行开始&quot;.center(scale//2,&quot;-&quot;))  # 填充start = time.perf_counter()for i in range(scale+1):    a = &#39;*&#39;*i    b = &#39;.&#39;*(scale - i)    c = (i/scale)*100    dur = time.perf_counter()-start    print(&quot;\r{:^3.0f}%[{}-{}]{:.2f}s&quot;.format(c,a,b,dur),end=&quot;&quot;) #默认end=&quot;\n&quot;    time.sleep(0.1)print(&quot;\n&quot;+&quot;执行结束&quot;.center(scale//2,&#39;-&#39;))</code></pre><h2 id="random库"><a href="#random库" class="headerlink" title="random库"></a>random库</h2><h3 id="基本随机数函数"><a href="#基本随机数函数" class="headerlink" title="基本随机数函数"></a>基本随机数函数</h3><pre><code>random.seed(10)random.random()   0.0-1.0之间的随机小数</code></pre><h3 id="扩展随机数函数"><a href="#扩展随机数函数" class="headerlink" title="扩展随机数函数"></a>扩展随机数函数</h3><pre><code>random.randint(a,b)      a-b之间的随机整数random.randrange(m,n,k)    m-n之间步长为k的随机整数random.getrandbits(k)         kbit长的随机整数</code></pre><pre><code>random.uniform(a,b)            a-b之间的随机小数random.choice(seq)             从seq中随机选择一个  random.shuffle(seq)               将seq打乱</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>try :    语句1 except:         (出错执行)    语句2else:            (正常执行)    语句3finally:          (一定会执行)    语句4</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>def 函数名(参数):    函数体    return 返回值</code></pre><pre><code>def getNum():      #获取用户不定长度的输入    nums=[]    iNumStr = input(&quot;请输入数字(回车退出)&quot;)    while iNumStr != &quot;&quot;:        nums.append(eval(iNumStr))        iNumStr = input(&quot;请输入数字(回车退出)&quot;)    return numsdef mean(numbers):    #计算平均值    s=0.0    for num in numbers:        s+=num    return s/len(numbers)def dev(numbers,mean):   #计算方差    sdev = 0.0    for num in numbers:        sdev = sdev+(num-mean)**2    return pow(sdev/(len(numbers)-1),0.5)def median(numbers):     #计算中位数    sorted(numbers)    size = len(numbers)    if size %2 ==0:        med = (numbers[size//2-1]+numbers[size//2])/2    else:        med = numbers[size//2]    return medn = getNum()m = mean(n)print(&quot;平均值:{},方差:{:.2},中位数:{}&quot;.format(m,dev(n,m)),median(n))</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><pre><code>变量名 = open(文件名,打开方式)变量名.close()</code></pre><pre><code>rt rb   以读模式打开，指针回到开头r+      以读写模式打开，指针回到开头，文件不存在报错wt wb   以写模式打开，指针回到开头w+       以读写模式打开，指针回到开头，文件不存在新建a       以写模式打开，指针在结尾，文件不存在新建a+     以读写模式打开，指针在结尾，文件不存在新建</code></pre><h3 id="文件内容读取"><a href="#文件内容读取" class="headerlink" title="文件内容读取"></a>文件内容读取</h3><pre><code>&lt;f&gt;.read(size)    读全部内容，前size长度的&lt;f.&gt;readline(size)  读一行内容，前size长度的&lt;f&gt;.readlines(hint) 读所有行，以每行为元素形成列表，前hint行的</code></pre><h3 id="文件内容写入"><a href="#文件内容写入" class="headerlink" title="文件内容写入"></a>文件内容写入</h3><pre><code>&lt;f&gt;.write(s)&lt;f&gt;.writelines(lines)&lt;f&gt;.seek(offset) 0 -开头 1-当前位置 2-结尾</code></pre><pre><code># 文本文件tf = open(&quot;f.txt&quot;,&quot;rt&quot;)print(tf.readline())tf.close()</code></pre><pre><code>#二进制文件bf = open(&quot;f.txt&quot;,&quot;rb&quot;)print(bf.readline())bf.close()</code></pre><pre><code>fo = open(&quot;output.txt&quot;,&quot;w+&quot;)ls =[&quot;中国&quot;,&quot;法国&quot;,&quot;美国&quot;]fo.writelines(ls)        # 可以写进去fo.seek(0)               #指针回到开头，打印出来for line in fo:    print(line)fo.close()</code></pre><h2 id="yield用法"><a href="#yield用法" class="headerlink" title="yield用法"></a>yield用法</h2><p>先把yield看成return<br>但return返回一个值后，程序结束</p><pre><code>def fun():    print(&quot;开始...&quot;)    while True:        res = yield 4        print(&quot;res:&quot;,res)g = fun()print(next(g))print(&quot;*&quot;*20)print(next(g))</code></pre><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><p>程序开始执行以后，因为fun函数中有yield关键字，所以fun函数并不会真的执行，<br>而是先得到一个生成器g(相当于一个对象)</p></li><li><p>直到调用next方法，fun函数正式开始执行，先执行fun函数中的print方法，然后进入while循环</p></li><li><p>程序遇到yield关键字，然后把yield想象成return,return了一个4之后，程序停止，<br>并没有执行赋值给res操作，此时next(g)语句执行完成，<br>所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果</p></li><li><p>程序执行，输出20个星 </p></li><li><p>又开始执行下面的print(next(g)),这个时候是从刚才那个next程序停止的地方开始执行的，<br>也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的<br>（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），<br>所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p></li><li><p>程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，<br>print函数输出的4就是这次return出的4</p></li><li><p>带yield的函数是一个生成器，而不是一个函数了，<br>这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，<br>这一次的next开始的地方是接着上一次的next停止的地方执行的，</p></li></ol><pre><code>def fun():    print(&quot;开始...&quot;)    while True:        res = yield 4        print(&quot;res:&quot;,res)g = fun()print(next(g))print(&quot;*&quot;*20)print(g.send(7))</code></pre><p>send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，<br>下次执行的时候只好继续执行赋值操作，只好赋值为None了，<br>而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,<br>然后执行next的作用，遇见下一回的yield，return出结果后结束</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探redis</title>
      <link href="/2020/04/27/chu-tan-redis/"/>
      <url>/2020/04/27/chu-tan-redis/</url>
      
        <content type="html"><![CDATA[<p>redis数据库与关系型数据库不同，是一种key-value型数据库。其中key只能是字符串，而value则可以是String、Hash Map、List、Set、Zset。每种类型的使用方式都不同。</p><hr><ul><li>String</li></ul><pre><code>set k1 v1get k1set k1 v11 get k1del k1get k1mset k1 v1 k2 v2mget k1 k2</code></pre><hr><ul><li>Hash Map</li></ul><pre><code>hset h1 name liminghget h1 namehmset h1 name liming age 11hgetall h1</code></pre><hr><ul><li>List</li></ul><pre><code>lpush L1 v1lrange L1 0 0lpush L1 v2 v3lrange L1 0 -1rpush L1 r1 r2 r3lrange L1 0 -1lpop L1</code></pre><hr><ul><li>Set</li></ul><pre><code>sadd S1 v1smembers S1sadd S1 v2smembers S1</code></pre><hr><ul><li>ZSet</li></ul><pre><code>keys *type &quot;proxies:mzitu&quot;zcard &quot;proxies:mzity&quot;zrange &quot;proxies:mzitu 0 -1 withscores</code></pre><hr><ul><li>docker 安装redis</li></ul><pre><code>docker pull redisdocker image ls -adocker run -dit -p 6379:6379 redis:latest redis-serverdocker  start -i 5ddocker exec -it 5d redis-cli</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我对manjaro的一些探索</title>
      <link href="/2020/04/27/wo-dui-manjaro-de-yi-xie-tan-suo/"/>
      <url>/2020/04/27/wo-dui-manjaro-de-yi-xie-tan-suo/</url>
      
        <content type="html"><![CDATA[<p>在初次接触linux时，我发现除了大众经常使用的Ubuntu系统外，还有人在使用manjaro。这个系统非常稳定，且不会像Ubuntu一样，经常找不到相应的软件。<br>但毕竟还是Ubuntu是老大哥，大树底下好乘凉，最终我还是选择了Ubuntu。不过我还是要记录一下我对manjaro的一些探索。</p><pre><code>sudo pacman-mirrors -c China更换镜像sudo pacman -Syyu更新软件git clone https://github.com/EvanMeek/Vanilla某个博主的i3配置sudo pacman -S docker安装dockersudo systemctl start docker启动docker服务systemctl enable docker开机自动启动docker</code></pre><p>OpenSSH</p><pre><code>sudo pacman -S openssh  #安装OpenSSH sudo systemctl enable sshd #开机自启sshd服务sudo systemctl start sshd #启动sshd服务 </code></pre><p>编辑器和shell</p><pre><code>sudo pacman -S vim安装vimsudo pacman -S code安装vscodesudo _E vim /etc/pacman.conf,去掉color注释sudo pacman -S  fish安装fishwhich fishchsh -s /user/bin/fish更改shell：bash--&gt;fishcurl -L https://get.oh-my.fish | fish安装oh my fish插件fish_config 更改fish配置omf install wttrwttr查看天气alias c clearfuncsave calias l &quot;ls -la&quot;funcsave lalias sudo &quot;sudo -E&quot;funcsave sudo fish shell下设置了 alias vim=nvim需要改回shell，才能用vim</code></pre><p>i3</p><pre><code>sudo pacman -S i3安装i3rebootwin(mod)+Enter开启终端win(mod)+Enter平行开启终端win(mod)+v+Enter竖直开启终端vim ~/.XresourcesXft.dpi:200变大字体reboot（mod）+1/2/3/4/5进入各个桌面vim ~/.config/i3/configset $mod Mod1bindsym $mod+Return exec alacrittymod）+Enter可以开启alacrittybindsym $mod+c exec firefox开启firefoxnew_window 1pixelexec_always  varietyexec_always comptonexec_always fcitx每次开启i3都会执行的命令(mod）+shift+r刷新i3---------------------------------------------------------------------------------------------------sudo pacman -S alacritty安装显卡渲染的终端sudo pacman -S dmenu安装（mod）+S可以在插入一个程序vim ~/.config/alacritty/alacritty.yml#Point sizesize:18调节alacritty字体#Background opactybackground_opacity:0.6设置半透明sudo pacman -S compton安装渲染器comptonsudo pacman -S fehfehsudo pacman -S varietyvariety换壁纸</code></pre><p>常用软件</p><pre><code>sudo pacman -S fcitx fcitx-im fcitx-configtoolsudo pacman -S fcitx-sougou搜狗输入法vim ~/.xprofileexport GTK_IM_MODEUL=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;系统环境变量rebootsudo pacman-S chromiumsudo pacman-S libofficesudo pacman-S transmission安装下载工具sudo pacman-S ranger</code></pre>]]></content>
      
      
      <categories>
          
          <category> 神器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的conda使用</title>
      <link href="/2020/04/27/wo-de-conda-shi-yong/"/>
      <url>/2020/04/27/wo-de-conda-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>conda是目前最流行的Python环境管理工具。conda的使用还是比较简单的，没有什么难度，只要熟悉相关的命令，便可用起来非常顺手。</p><p>我在使用conda过程中，偶尔会去百度conda的相关命令，因此在这里记录下我常用的conda命令。</p><pre><code>conda list查看安装了哪些包conda env listconda info -e查看当前存在哪些虚拟环境conda update conda检查更新当前condaconda create -n your_env_name python=X.X（2.7、3.6等)创建python版本为X.X、名字为your_env_name的虚拟环境python --version可以检查当前python的版本source activate your_env_name(虚拟环境名称)conda install -n your_env_name [package]即可安装package到your_env_name中source deactivateconda deactivate退出python虚拟环境conda remove -n your_env_name(虚拟环境名称) --all删除虚拟环境conda remove --name your_env_name  package_name 、删除虚拟环境中的包conda create -n tf --clone rcnn克隆虚拟环境rcnn到tfconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes设置清华镜像源conda config --show channels显示所有的镜像下载通道conda config --remove channels &#39;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/＇删除镜像conda install nb_conda_kernels在jupyternotebook安装虚拟环境conda config --remove-key channels恢复到默认源cd ~vim .bashrcexport PYTHONIOENCODING=utf-8source .bashrc设置python输入输出环境变量</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的i3、tmux、ranger使用</title>
      <link href="/2020/04/26/wo-de-i3-tmux-ranger-shi-yong/"/>
      <url>/2020/04/26/wo-de-i3-tmux-ranger-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="ranger"><a href="#ranger" class="headerlink" title="ranger"></a>ranger</h2><p>ranger是一个文件管理器，可以让我们在终端下方便快捷的操作文件和文件夹，我的ranger配置文件可以在我的<a href="https://github.com/beichen1994/MyLinuxConfig/tree/master/.config" target="_blank" rel="noopener">github仓库</a>中找到。</p><p>ranger的操作方式有点类似vim，下面是我的常用命令</p><pre><code>hjkl左下上右gh (/homegm (/mntgd (/devgp (/tmpcw 重命名pp 粘贴dd 剪切yy 复制space 选中</code></pre><p>在安装与配置ranger时，我是参照了以下教程</p><ul><li><p><a href="http://www.huangpan.net/posts/ji-ke/2019-08-21-ranger.html#toc-heading-75" target="_blank" rel="noopener">Ranger 用法总结</a></p></li><li><p><a href="https://www.cnblogs.com/zhangsf/p/3322627.html" target="_blank" rel="noopener">ranger文件管理器</a></p></li><li><p><a href="https://wiki.archlinux.org/index.php/ranger_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">ranger文档</a></p></li></ul><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>tmux可以让我们在一个终端中同时开启多个会话，看起来更加酷炫，从此不再多个窗口来回切换。但是比较受限于屏幕大小，如果屏幕太小，窗口被切分的太小，看起来不舒服。</p><p>我常用的tmux命令如下:</p><hr><ul><li>启动与退出</li></ul><pre><code>tmuxexit</code></pre><hr><ul><li>会话（Session）管理</li></ul><pre><code>tmux lstmux new -s mysesstmux detachtmux attach -t mysesstmux switch -t mysesstmux rename-session -t 0 bctmux kill-session -t mysess</code></pre><hr><p>*窗格（pane）管理</p><pre><code>tmux split-window划分上下两个窗格tmux split-window -h划分左右两个窗格tmux select-pane -U光标移动到上方窗格tmux select-pane -D光标移动到下方窗格tmux select-pane -L光标移动到左方窗格tmux select-pane -R光标移动到右方窗格tmux swap-pane -U当前窗格上移tmux swap-pane -D当前窗格下移</code></pre><hr><ul><li>快捷键</li></ul><pre><code>Ctrl+b    %划分左右两个窗格Ctrl+b    &quot;划分上下两个窗格Ctrl+b    箭头光标移动到其他窗格Ctrl+b    {当前窗格左移Ctrl+b    }当前窗格右移Ctrl+b    Ctrl+o当前窗格上移Ctrl+b    Alt+o当前窗格下移Ctrl+b x关闭当前窗格Ctrl+b !将当前窗格拆分为一个独立窗口Ctrl+b q显示窗格编号窗口管理tmux new-window  -n bc1新建一个窗口tmux select-window -t bc1切换窗口tmux rename-window bc1重命名窗口快捷键Ctrl+b    c创建一个新窗口Ctrl+b    w从列表中选择窗口Ctrl+b    ,重命名窗口Ctrl+b    p切换到上一个窗口Ctrl+b    n切换到下一个窗口Ctrl+b    窗口编号切换到指定编号的窗口</code></pre><h2 id="i3"><a href="#i3" class="headerlink" title="i3"></a>i3</h2><p>i3是一个可以高度自定义的窗口管理器，对于i3的安装与配置，我是参考了以下4个教程。</p><ul><li><p><a href="https://blog.csdn.net/mkosto/article/details/97238317" target="_blank" rel="noopener">手把手教你使用Linux安装i3wm桌面</a></p></li><li><p><a href="https://www.jianshu.com/p/f4b3abc9a282" target="_blank" rel="noopener">Ubuntu18+i3配置</a></p></li><li><p><a href="https://www.jianshu.com/p/81917864271e" target="_blank" rel="noopener">ubuntu系统配置i3wm窗口管理器</a></p></li><li><p><a href="https://i3wm.org/docs/" target="_blank" rel="noopener">i3文档</a></p></li></ul><p>我的i3配置文件可以在我的<a href="https://github.com/beichen1994/MyLinuxConfig/tree/master/.config" target="_blank" rel="noopener">github仓库</a>中找到</p>]]></content>
      
      
      <categories>
          
          <category> 神器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的docker使用</title>
      <link href="/2020/04/26/wo-de-docker-shi-yong/"/>
      <url>/2020/04/26/wo-de-docker-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;初次使用docker完全是处于一个想法，我想用docker打造一个我的Python环境，随时打包，随时分享！我是在Ubuntu上安装并使用docker，安装方式可以完全采用菜鸟教程中的<a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">Ubuntu Docker安装</a>.</p><p>&ensp;&ensp;我们首先需要在dockerhub创建一个账号，有点类似github平台，里面的仓库是有公私之。我们可以编写dockerfile来创建自己的镜像。我偷了下懒，直接pull了官方的Ubuntu镜像并创建容器。在这个容器里安装自己的Python环境。如果要使用的话，需要进入该容器中，再运行自己的Python程序。当然了我们也可可以使用vscode，通过ssh连接到docker容器中，这个远程连接并运行程序的功能是免费的，不想Pycharm需要升级到企业版才可以使用，所以VScode真的是良心产品。由于我的镜像中会包含一些我的文件，所以我将仓库设为了私有，如果你想使用，可以通过邮箱联系我。由于我是个初学者，我的docker镜像越来越大，竟也有十几G之大。不过我还是可以接受的。</p><p>&ensp;&ensp;这张图非常形象的描绘了docker的使用原理。<br><img src="https://s1.ax1x.com/2020/04/27/JRcidI.png" alt="JRcidI.png"></p><p>&ensp;&ensp;下面我将介绍常用的docker命令</p><pre><code>docker login 登录docker logout  退出docker登录docker pull beichen1994/python:v1   下载beichen1994仓库下的python:v1镜像</code></pre><pre><code>docker image ls -a  列出本地所有镜像docker image rm 9eeba   删除镜像docker rmi centos/centos:7.2删除其中一个镜像，这里的镜像有两个repo引用，并且没有容器使用即删除时指定名称，而不是IMAGE ID。先查询依赖docker image inspect --format=&#39;{{.RepoTags}} {{.Id}} {{.Parent}}&#39; $(docker image ls -q --filter since=XXX)    # XXX指镜像ID然后根据根据TAG删除容器docker rm REPOSITORY:TAGdocker container ls -a  列出本地所有容器docker container rm a43d5   删除容器 docker container prune  删除所有容器docker container logs  查看容器日志docker container start a43d5  启动关闭的容器docker container stop a43d5  关闭容器</code></pre><pre><code>docker commit -a&quot;beichen1994&quot; -m&quot;all kinds of python environment&quot; 3976 py_env使用 docker commit 命令来将容器打包为镜像docker tag py_env:latest beichen1994/python:v3将这个新镜像打上 tag，方便在公共服务器进行上传docker push beichen1994/python:v4上传镜像</code></pre><pre><code>docker export 7691a814370e &gt; ubuntu.tar  导出容器docker import - test/ubuntu:v1   导入容器docker inspect 89fc 查看docker容器详细信息docker inspect --format=&#39;{{.NetworkSettings.IPAddress}}&#39;628a windows:172.17.0.2</code></pre><pre><code>docker run；创建和启动一个新的容器实例，操作对象是镜像docker run -dit -p 5592:5592 -p 5593:5593 -p 8022:22 -p 12345:8888 -p 6006:6006 -v /C/Users/86176/Desktop/python:/home/python  beichen1994/python:v2  /bin/bash新建容器，宿主机与docker的端口映射，容器名，镜像和路径映射docker exec:在已运行的容器中，执行命令，操作对象是容器,并且退出时，容器不会停止docker exec -it 69d1 /bin/bash 在新的终端进入正在运行的容器docker start: 启动已经停止的容器docker start -i 282fae指定交互式，启动282fae容器</code></pre><pre><code>注意 在docker容器中共 /lib/systemd/system/docker.service 中 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375 才会正常显示端口</code></pre><pre><code>jupyter notebook --port 8888 --ip 0.0.0.0 --allow-rootdocker运行jupyter</code></pre><pre><code>sudo apt-get remove docker docker-engine docker.io docker-cesudo apt-get autoremove卸载docker</code></pre><p>docker 镜像下载速度慢？不急！快看下面</p><pre><code>cd /etc/dockervi daemon.json（如果没有，就新建一个）{    &quot;registry-mirrors&quot;:[&quot;https://almtd3fa.mirror.aliyuncs.com&quot;]      }service docker restart</code></pre><p>下载速度飞起！！</p>]]></content>
      
      
      <categories>
          
          <category> 神器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的vim使用</title>
      <link href="/2020/04/26/wo-de-vim-shi-yong/"/>
      <url>/2020/04/26/wo-de-vim-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;很多人都说vim是最好用的编辑器，抱着好奇的心理我尝试了。的确，好用是好用，但想改变windows记事本类型的编辑器的使用习惯好难。。。(捂脸)</p><p>&ensp;&ensp;vim使用需要搭配配置文件以及安装所需的插件，具体的配置文件.vimrc,可以参考我的<a href="https://github.com/beichen1994/MyLinuxConfig/blob/master/.vimrc" target="_blank" rel="noopener">github仓库</a></p><p>&ensp;&ensp;感兴趣的朋友也可以直接查看<a href="http://vimcdoc.sourceforge.net/" target="_blank" rel="noopener">vim文档</a></p><p>&ensp;&ensp;使用vim少不了命令操作，下面我介绍一下常用的vim命令，总结下来无外乎定位、插入、删除、替换、重复、匹配、查找、可视化</p><hr><ul><li>定位</li></ul><pre><code>左下上右hjkl 按word定位w 按单词尾定位e 按单词头定位b加上数字倍数5w2b9l直接行首0直接行尾$直接文本首gg直接文本尾G2G </code></pre><hr><ul><li>插入</li></ul><pre><code>在后方插入i 插入3个go3i go jj(ESC)在前方插入a插入o插入O</code></pre><hr><ul><li>删除</li></ul><pre><code>x  //删除X  //删除d  //删除dw  //删除wordde  //删除endd2e   //删除两个单词</code></pre><hr><pre><code>yy   //复制dd   //剪切pp   //粘贴</code></pre><hr><ul><li>替换</li></ul><pre><code>替换成ere  </code></pre><hr><ul><li>匹配与查找</li></ul><pre><code>匹配括号%查找wfw查找3个q3fq查找text  /text 查找下一个text/text n</code></pre><hr><ul><li>可视化</li></ul><pre><code>v   //可视化模式V   //可视化模式v e l d  //进入可视化，选中e，向右移动，删除</code></pre><hr><ul><li>退出</li></ul><pre><code>wq 存盘并退出wq! 存盘并强制退出q!  只强制退出</code></pre><p>由于我设置了配置文件，所以我的自定义退出方式如下</p><pre><code>,w 保存,q 退出</code></pre>]]></content>
      
      
      <categories>
          
          <category> 神器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的Ubuntu常用命令</title>
      <link href="/2020/04/26/wo-de-ubuntu-chang-yong-ming-ling/"/>
      <url>/2020/04/26/wo-de-ubuntu-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;既然使用了Ubuntu，那当然想能够发挥她的最大效用啦，为了可以更好的使用Ubuntu，有必要熟悉并掌握如下命令</p><hr><pre><code>切换到root用户su root为root用户设置密码sudo passwd root切换到wyq用户su wyq更新sudo apt-get update安装依赖包sudo apt --fix-broken install</code></pre><hr><ul><li>清理</li></ul><pre><code>清理旧版本的软件缓存apt-get autoclean清理所有软件缓存apt-get clean删除系统不再使用的孤立软件apt-get autoremove</code></pre><hr><ul><li>文件夹/文件常规操作</li></ul><pre><code>列出文件ls定位目录cd /home/spider打印工作目录pwd生成文件夹mkdir  spider生成1.txt文件touch 1.txt复制1.txt到2.txtcp /home/spider/1.txt  /home/wyq/Desktop/spider/2.txt重命名mv filename1 filename2移动文件 mv filename dirname删除文件/文件夹rm -rf filename/dirname批量删除find . -type f -name &quot;*something*&quot;find . -type f -name &quot;*something*&quot; -delete递归修改文件夹权限为777chmod -R 777 dirname</code></pre><hr><ul><li>压缩与解压缩</li></ul><pre><code>解压zipunzip FileName.zip 解压文件夹下所有zipls *.zip | xargs -n1 unzip -o将DirName本身压缩zip FileName.zip DirName 压缩，递归处理，将指定目录下的所有文件和子目录一并压缩zip -r FileName.zip DirNamerar压缩与解压sudo apt-get install rarrar a filename.rar filename/sudo apt-get install unrarunrar x update.rar update/unrar e update.rar解压p7zipsudo apt-get install p7zip7z x filename.7z -r -o/home/xx解压tartar -zxvf archive_name.tar.gztar -zxvf archive_name.tar.gz -C /tmp/extract_here/</code></pre><hr><ul><li>硬盘挂载</li></ul><pre><code>cd /mntmkdir disk查看所有硬盘sudo fdisk -l查看该硬盘的文件类型file -s /dev/sdb1挂载硬盘sudo mount -t ext4 /dev/sdb1 /mnt/disk/卸载硬盘sudo umount /dev/sdb1挂载外接盘mount  /dev/sdc1 /mnt修改文件夹下所有文件的权限sudo chmod -R 775 spider</code></pre><hr><ul><li>查找</li></ul><pre><code>查找软件安装目录sudo find / -name chromium-browserwhereis chromium-browserwhich chromium-browser</code></pre><hr><ul><li>ubuntu用命令启动程序</li></ul><pre><code>sudo vim ~/.bashrc然后，在打开的.bashrc中添加如下的数据：export PATH=$PATH:/opt/google/chrome  //后面是chrome所在的目录export PATH=$PATH:/opt/baidunetdisk然后，保存。重新打开一个新的终端google-chromebaidunetdisk</code></pre>]]></content>
      
      
      <categories>
          
          <category> 神器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的ubuntu必备工具与软件</title>
      <link href="/2020/04/26/wo-de-ubuntu-bi-bei-gong-ju-yu-ruan-jian/"/>
      <url>/2020/04/26/wo-de-ubuntu-bi-bei-gong-ju-yu-ruan-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&ensp;&ensp;我使用ubuntu也有一段时间了，越用感觉越好用，甚至一度想弃用windows，但无奈有些软件只有win版，无奈只能将ubuntu作为辅助工具使用。在使用过程中，我觉得有些软件是很好用且是必装的，在这里记录一下。</p><h2 id="必装软件"><a href="#必装软件" class="headerlink" title="必装软件"></a>必装软件</h2><ul><li>software update</li></ul><blockquote><p>这个不是软件，是ubuntu中的软件更新，一开始要注意配置其中的软件源，否则在安装或更新软件时，会报错。配置好之后，运行一下代码。</p></blockquote><pre class="line-numbers language-python"><code class="language-python">sudo apt<span class="token operator">-</span>get update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>synergy</li></ul><blockquote><p>这个软件简直不能再方便，可以让我们用一副键鼠同时操作多台电脑，比如我现在就在用Surface作为主机使用，将ubuntu作为客户机使用，只使用Surface的键鼠就可以同时操作Surface与Unbuntu.</p></blockquote><ul><li>ssh</li></ul><blockquote><p>这个就不多说了，远程连接必备，必装！</p></blockquote><ul><li>samba</li></ul><blockquote><p>这个软件可以将共享文件夹映射到windows，从此我们可以愉快的在windows中操作linxu中的文件夹了,访问速度还是比较快,但是别忘了给足权限喔。具体使用可以参考(<a href="https://www.cnblogs.com/gzdaijie/p/5194033.html)、(https://www.linuxidc.com/Linux/2018-11/155466.htm)" target="_blank" rel="noopener">https://www.cnblogs.com/gzdaijie/p/5194033.html)、(https://www.linuxidc.com/Linux/2018-11/155466.htm)</a></p></blockquote><ul><li>git</li></ul><blockquote><p>这个对于程序员来说并不陌生，平时写代码或者写作，都可以通过git同步到github平台。让我们的代码和文章管理更加规范化。但学习成本还是比较高，但是也是比较值得学习并使用的。</p></blockquote><ul><li>vscode</li></ul><blockquote><p>绝对良心的编辑器，有了她，你不再需要其他的编辑软件，有了她，她就是你的唯一！她就像一个变形金刚，你给了她什么插件，她就变成什么！</p></blockquote><blockquote><p>推荐本地插件:<br>Chinese Langeage Pack for Visual Studio Code、Python、 Markdownlint、Markdown Preview Enhanced、Latex Workshop、Remote-SSH、Remote-SSh:Editing Configuration Files、</p></blockquote><blockquote><p>推荐远程插件:<br>Chinese Langeage Pack for Visual Studio Code、Python、Python for Vscode、Jupyter、VSCode Jupyter Notebook Previewer、</p></blockquote><ul><li>vim</li></ul><blockquote><p>都说vim是最好用的编辑器，这个软件对于用惯了windows记事本之类编辑器的人来说简直是噩梦。我一开始使用的时候，一脸懵逼，这是什么玩意！学习成本也非常高。但如果真的用好了的话，那将是一种非凡的享受。我目前也是刚刚入门，对于vim的使用也是一知半解。vim使用的话，需要配合配置文件.vimrc以及需要安装一些插件vim-plug，感兴趣的话，可以参考一下我的github中有相关vim配置文件。</p></blockquote><ul><li>ranger</li></ul><blockquote><p>对于终端用户来说，这个软件是一个福音，他给了我们一个在终端中可视化操作文件的方式。安装方式也非常简单，直接在终端中输入 sudo apt-get install ranger即可。操作方式有点类似vim，具体操作指令也需要学习一下。</p></blockquote><ul><li>tmux</li></ul><blockquote><p>这个是一个终端多开的软件，我们可以在一个终端中同时打开多个会话，每个会话都可以相当于一个终端。从此我们不再需要打开好多个终端界面，来回进行切换！！</p></blockquote><ul><li>docker</li></ul><blockquote><p>这个相当于一个虚拟机，安装之后，可以进入到创建的的容器中，进行我们想要的操作。有时我们在共享我们的代码或者应用时，在我们的环境中是可以正常运行的，但到了别人的环境中就会报错。所以我们可以在docker容器中进行操作，将整个容器打包为镜像，分享给别人。在docker hub中已经有很多已经打包好的docker镜像供我们使用，如ubuntu镜像，mysql镜像，redis镜像等，所以我们在使用一些应用时，可以直接pull我们想要的镜像即可，方便快捷。</p></blockquote><blockquote><p>我之所以使用docker，是因为我想打造一个自己的Python环境，在这个容器里，我安装了各种我需要的Python环境，当我更换电脑时，我不用一遍遍的重复安装python环境，而是直接pull我的docker镜像，里面就已经包装好了我需要的Python环境。当然了我基于的还是ubuntu镜像。</p></blockquote><ul><li>miniconda</li></ul><blockquote><p>有时候docker中的Python环境需要开放端口进行浏览器的可视化，docker是没有界面的，所以不得已在本地中安装了miniconda。以备不时之需吧。</p></blockquote><ul><li>npm+hexo</li></ul><blockquote><p>这个是为了写博客用的。</p></blockquote><ul><li>latex环境</li></ul><blockquote><p>这个是为了编写latex文件用的。</p></blockquote><ul><li>chrome google-access-helpser</li></ul><blockquote><p>我觉得chrome浏览器是最好用的浏览器之一，不过由于在国内需要科学上网才能更好的发挥chrome浏览器的功效，所以，我不得已使用了google-access-helper，虽然还是无法科学上网，但至少让我可以同步我的chrome标签。</p></blockquote><ul><li>smplayer</li></ul><blockquote><p>linux下的视频播放器，比较无感</p></blockquote><ul><li>shutter</li></ul><blockquote><p>linux下的截图软件，也比较无感</p></blockquote><ul><li>sougou输入法</li></ul><blockquote><p>没办法，中文输入始终是不太友好，这个也只能是将就使用</p></blockquote><ul><li>goldendict</li></ul><blockquote><p>ubuntu下的翻译软件，还在使用中，</p></blockquote><ul><li>teamviewer</li></ul><blockquote><p>异地远程控制软件，和通过ssh连接方式不同，通过外网来进行连接，所以有时候会变得非常卡顿。甚至被识别为商业用户，限制使用时间。现在已经不怎么使用了。</p></blockquote><ul><li>i3+lightdm(登录管理)+compton+feh</li></ul><blockquote><p>对于Ubuntu用户来说，使用gnome桌面软件可能与windows并无两样。我们可以使用i3桌面，非常轻量化，不会过多占用系统资源。通过i3配置文件自定义我们的桌面环境，最重要的是，它采用的是平铺式窗口，且可以半透明化，使用起来非常舒服。</p></blockquote><blockquote><p>如果使用i3，还需要同时安装compton（sudo apt-get install compton）(~/.config/compton.conf)和feh(sudo apt-get install feh)(feh –fig-scale ~/Pictures/wallpaper/wallpaper01.jpg)</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&ensp;&ensp;以上都是我在使用ubuntu过程中一直在使用的工具和软件，如果对你有帮助，我会非常高兴。</p>]]></content>
      
      
      <categories>
          
          <category> 神器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Daily Dictation</title>
      <link href="/2020/04/21/daily-dictation/"/>
      <url>/2020/04/21/daily-dictation/</url>
      
        <content type="html"><![CDATA[<p><em>Mother Teresa, who received a Nobel Peace Prize for her work(on behalf of) for the poor, dies in CalcuHa, India - she was 87 years old.</em></p><p>Jerry, what time do you have?<br><em>Sir, what time do you have?</em><br>I have 5 o’clock.</p><p>There are three things I have learned.<br>Never to discuss with people, religon, politics and the Great Pumkin.</p><p>Now let somebody tell you, you can’t do some.<br><em>Don’t ever let somebody tell you you can’t do something.</em></p><p>I have come here to true  bombgang and kick ass and all the bombgang.<br><em>I have come here to chew bubblegum and kick ass… and I’m all out of bubblegum!</em></p><p>seak alive  every moment</p>]]></content>
      
      
      <categories>
          
          <category> 英文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>词袋模型</title>
      <link href="/2020/03/25/ci-dai-mo-xing/"/>
      <url>/2020/03/25/ci-dai-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="文档信息向量化"><a href="#文档信息向量化" class="headerlink" title="文档信息向量化"></a>文档信息向量化</h1><p>数学家总喜欢用向量，所以称之为文档信息的向量化，实质是将文档信息数值化。我们可以提取多少信息，模型就可以分析出多少信息。</p><h2 id="One-hot-Big-of-Words-BOW-词袋模型"><a href="#One-hot-Big-of-Words-BOW-词袋模型" class="headerlink" title="One-hot/Big of Words/BOW/词袋模型"></a>One-hot/Big of Words/BOW/词袋模型</h2><p>将文本直接简化为一系列词的集合，每个词都是独立的</p><ol><li><p>分词，对每个词编号，形成字典<br> 大鱼吃小鱼也吃虾米，小鱼吃虾米<br> {‘大鱼’:1,’吃’:2,’小鱼’:3,’也’:4,’虾米’:5}</p></li><li><p>用0/1代表该词是否出现过，从而将文本表示为一个特征向量</p><p> 大鱼吃小鱼也吃虾米<br> [大鱼，吃，小鱼，也，吃，虾米]</p><p> [大鱼，吃，小鱼，也，虾米]<br> [1,2,1,1,1]</p><p> 小鱼吃虾米<br> [小鱼，吃，虾米]</p><p> [大鱼，吃，小鱼，也，虾米]<br> [0,1,1,0,1]</p></li></ol><ul><li><p>优点：解决了分类器不好处理离散数据的问题</p></li><li><p>缺点<br>  不考虑词与词之间的顺序与前后关系<br>  特征向量是离散稀疏的，每个词都是茫茫0海中的1.</p></li></ul><h2 id="Set-of-Words-词级模型"><a href="#Set-of-Words-词级模型" class="headerlink" title="Set of Words/词级模型"></a>Set of Words/词级模型</h2><p>大鱼吃小鱼也吃虾米<br>[大鱼，吃，小鱼，也，吃，虾米]</p><p>[大鱼，吃，小鱼，也，虾米]<br>[1,1,1,1,1]</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neural network and deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习-Kears+TensorFlow</title>
      <link href="/2020/03/23/shen-du-xue-xi-kears-tensorflow/"/>
      <url>/2020/03/23/shen-du-xue-xi-kears-tensorflow/</url>
      
        <content type="html"><![CDATA[<p>Tensorflow: 作为google主推的深度学习框架，未来支持会更好</p><p>Keras：跨平台兼容，后台Tensorflow/Theano均可，可以直接当黑箱使用，速度稍慢，隐藏了很多内部参数</p><p>Keras+Tensorflow组合：以Keras为主，用tensorflow语句来写扩展功能并和Keras结合使用。</p><p>Tensorflow安装：</p><ul><li>CPU版本: pip3 install –upgrade tensorflow</li><li>GPU版本: pip3 install –upgrade tensorflow-gpu，需要进一步安装CUDA和cuDNN。</li></ul><p>Keras安装:</p><ul><li><p>依赖包：numpy，scipy，pyyaml，HDF5，h5py，如果拟合CNN（卷积神经网络），推荐安装cuDNN。</p></li><li><p>后端框架：Tensorflow</p></li><li><p>pip install keras -U –pre</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neural network and deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习-RNN</title>
      <link href="/2020/03/23/shen-du-xue-xi-rnn/"/>
      <url>/2020/03/23/shen-du-xue-xi-rnn/</url>
      
        <content type="html"><![CDATA[<h2 id="传统的BP-back-propagation-神经网络结构"><a href="#传统的BP-back-propagation-神经网络结构" class="headerlink" title="传统的BP(back propagation)神经网络结构"></a>传统的BP(back propagation)神经网络结构</h2><ul><li>分为输入层,隐含层,输出层三层.在输出层,比较预测值与实测值,得到误差,调整隐含层的连接权重,并动态增删神经元</li><li>具体的网络输出并不会影响下一次的网络输入信号,最终保留的是隐含层的结构和连接权重</li></ul><h2 id="Recurrent-Neural-Network"><a href="#Recurrent-Neural-Network" class="headerlink" title="Recurrent Neural Network"></a>Recurrent Neural Network</h2><p>文本是典型的<strong>序列数据</strong>,后续的文本内容和前导文本内容之间存在<strong>语义关联</strong>,传统的神经网络模型并不能匹配这一数据特征.</p><p>希望分类器能够记得上下文的内容并用于预测,特别是将上文内容用于预测.</p><p>RNN是包含循环的神经网络,允许原有输入信息的持久化,RNN是对应问嗯这汇总序列类型数据的最自然的神经网络架构</p><p>每个节点的计算,都是基于当前输入和原先输入内容的<strong>记忆</strong>(原先的输出)而来</p><p>$$<br>s_{t} = f(Ux_{t}+Ws_{t-1})<br>$$</p><p>$Ux_{t}$中$U$是新数据所占的百分比<br>$Ws_{t-1}$中$W$是原先输入的记忆所占的百分比<br>$s_{t}$是输入的节点</p><p>RNN存在的问题</p><ul><li>RNN的记忆力不够久!当相关信息和预测词位置之间的间隔小时,RNN的表现很好.但是需要联想前面很远的信息进行预测! The vanishing(消失的) gradient probelm for RNNs.</li></ul><h2 id="Long-Short-Term网络"><a href="#Long-Short-Term网络" class="headerlink" title="Long Short Term网络"></a>Long Short Term网络</h2><ul><li><p>属于RNN的一种网络,可以学习长期依赖信息.</p></li><li><p>好记性不如烂笔头，LSTM默认数据中有很多长期信息，因此直接用一个小本子(cell)来记录信息</p></li><li><p>但是信息中也有很多无用的，因此模型会随机丢弃一部分信息，通过模型训练，不断保留有价值的信息，丢弃无用的信息</p></li><li><p>cell状态：在图上水平贯穿运行。类似于传送带，信息在上面持续传输，中间会有各种门进行信息流的更新。</p></li><li><p>门：用于控制信息的增加和减少的阀门。输出一个0-1之间的值，1表示这一趟的信息全部输入信息流，0表示这一趟的信息全部忘记（信息流无变化）</p></li><li><p>忘记门：决定从cell状态中丢弃什么信息，它把上一次的状态$h_{t-1}$和这一次的输入$x_{t}$合并进行处理。即$$f_{t} = \sigma(W_{f}.(h_{t-1},x_{t})+b_{f})$$，$f_{t}$会在更新门中从原有的cell状态中减去。<br><img src="https://s1.ax1x.com/2020/03/23/87SVQP.png" alt="87SVQP.png"></p></li><li><p>记忆门：哪些信息应该被记住，首先，用$sigmoid$决定什么信息需要被忘记。即$$i_{t} = \sigma(W_{i}.(h_{t-1},x_{t})+b_{i})$$，然后用$tanh$决定哪些新增信息需要被记住，即$$C_{t} = \sigma(W_{C}.(h_{t-1},x_{t})+b_{C})$$<br><img src="https://s1.ax1x.com/2020/03/23/87SAzt.png" alt="87SAzt.png"></p></li><li><p>更新门：把老的cell状态更新为新的cell状态，XOR：去除$f_{t}$和$C_{t-1}$中相同的信息，比如，$f_{t}$中有1，$C_{t-1}$中有1，2，3，则更新门输出2，3. AND：增加信息。将忘记门中的信息与记忆门中的信息合并，即$$C_{t}=f_{t} XOR C_{t-1} AND i_{t} XOR C_{t}$$，得到当前单元的cell状态。<br><img src="https://s1.ax1x.com/2020/03/23/87SneS.png" alt="87SneS.png"></p></li><li><p>输出门：由记忆即$C_{t}$来决定输出什么值。即$$o_{t} = \sigma(W_{o}(h_{t-1},x_{t})+b_{o})$$,$$h_{t}=o_{t}*tanh(C_{t})$$<br><img src="https://s1.ax1x.com/2020/03/23/87SkRI.png" alt="87SkRI.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neural network and deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TotalCommand</title>
      <link href="/2020/03/21/totalcommand/"/>
      <url>/2020/03/21/totalcommand/</url>
      
        <content type="html"><![CDATA[<p>TotalCommand一般被称为TC，是windows下的一款资源管理器，有了她，windows下的所有文件皆被玩弄于鼓掌之间，哈哈！！</p><h2 id="目录与磁盘跳转"><a href="#目录与磁盘跳转" class="headerlink" title="目录与磁盘跳转"></a>目录与磁盘跳转</h2><p>Tab 切换左右窗口</p><p>alt+F1 左窗口磁盘</p><p>alt+F2 右窗口磁盘</p><p>alt+左/右  在历史目录前进后退</p><p>alt+下 显示所有历史目录</p><p>ctrl+d+字母 跳转目录</p><p>ctrl+/ 跳到根目录</p><p>ctrl+b 显示所有文件</p><p>ctrl+b 回到正常模式</p><p>backspace  跳到父目录</p><h2 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h2><p>alt+F7 搜索文件</p><p>xxx+enter 快速搜索并进入 </p><p>F3 预览</p><p>ESC 退出预览</p><p>ctrl+q 在另一侧预览</p><p>ctrl+q 退出预览</p><p>ctrl+end 跳到结尾</p><h2 id="小tip"><a href="#小tip" class="headerlink" title="小tip"></a>小tip</h2><p>shift+F4 新建文件</p><p>ctrl+3 复制所有文件的文件名</p><p>ctrl+z 对文件注释</p><p>alt+1/2/4/6 显示隐藏工具栏等</p><p>ctrl+F8 显示文件夹树</p><p>文件管理：定位+选择+操作</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>lister plugins 查看插件   wlx</p><p>packer plugins 压缩插件    wcx</p><p>file system plugins 文件系统插件  wfx  </p><p>content plugins 内容插件  wdx</p><p>实质上都是dll，把一些文件复制到TC下的plugin目录下，并在对应的配置文件ini中做相应的配置记录</p>]]></content>
      
      
      <categories>
          
          <category> 神器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>技术的本质</title>
      <link href="/2020/03/21/ji-zhu-de-ben-zhi/"/>
      <url>/2020/03/21/ji-zhu-de-ben-zhi/</url>
      
        <content type="html"><![CDATA[<p>作者：[美] 布莱恩.阿瑟</p><hr><ul><li><p>“技术的本性” technology-ness</p></li><li><p>技术，是新的技术产品和生产工艺通过被应用和被采用而获得改善，之后在获得进一步地应用和采用，进而创造出正反馈或者收益递增的效用。</p></li><li><p>技术呈现之初，那些看起来模模糊糊的状态</p></li><li><p>技术是由其他的技术构成的，技术产生于其他技术的组合。</p></li><li><p>技术是由部件和零件（集成件和次级集成件）构成的，而集成件自身也是技术。所以技术有一个递归性（recursive）地结构。</p></li><li><p>技术是什么，它是如何进化的？</p></li><li><p>技术（technology）、创新（innovation）、技艺（technique）内涵往往相互重叠，又相互矛盾。</p></li><li><p>首先需要界定属于，然后由此逻辑地导出结果和属性。</p></li></ul><p>Question: 作者是如何探究这个问题，以及如何构思的？</p><hr><h2 id="第一章-问题"><a href="#第一章-问题" class="headerlink" title="第一章 问题"></a>第一章 问题</h2><ul><li><p>是技术将我们与中世纪分离得，的确，是技术将我们与我们拥有了5万年甚至更久的那中共生活方式分开了。技术无可比拟的创造了我们的世界，它创造了我们的财富，我们的经济，还有我们的存在方式。</p></li><li><p>技术的循环：技术总是这样的循环，为解决老问题去采用新技术，新技术又引起新问题，新问题的解决又要诉诸更新的技术。我们的不安就来自于对这种循环会无休止地进行下去的恐惧。</p></li><li><p>我们会被两种巨大的、难以察觉的力量所左右：一个是我们人类寄托在技术上的深切的希望；另一个是我们对自然的最深切的信赖。这两种力量的斗争就如同漫长岁月中大陆板块之间那些无情的碰撞一样。</p></li><li><p>什么是技术？它的最深的本质是什么？它的特性和原理是什么？它从哪里来的？它是如何形成的？它又是如何发展的？它是如何进化的？</p></li></ul><h3 id="缺失了本质的技术"><a href="#缺失了本质的技术" class="headerlink" title="缺失了本质的技术"></a>缺失了本质的技术</h3><ul><li><p>我们缺失的是一个关于技术的理论–一门关于技术的“学”。</p></li><li><p>关于技术的理论之所以缺失，是因为：技术一直处于科学的引用之中。那些认真思考技术的人大多数是社会学家和哲学家。</p></li></ul><p>Question: 科学的社会功能是什么？技术的本质是什么？</p><h3 id="技术的进化"><a href="#技术的进化" class="headerlink" title="技术的进化"></a>技术的进化</h3><ul><li><p>“进化”的完整含义：某类事务的所有对象衍生于其以往对象的集合的过程，并且这一过程是依据类似“血统”这种纽带相关联的。</p></li><li><p>喷气机不是内燃机或任何其他先前技术的变种，它也不是在其“前任”技术基础上稳步积累形成的。所以解释这种“新颖性”(novelty)，即一种突发的、根本的新颖性，成了技术进化论者最主要的障碍。</p></li><li><p>但是当我们面对主要问题，如根本性的新技术是如何产生的，这相当于达尔文理论中的生物新物种是如何产生的问题，我们就遇到了阻碍，达尔文原理就不好用了。</p></li></ul><p>###　组合进化</p><ul><li><p>如果完整意义上的进化存在于技术中，那么所有的技术，包括新技术，一定是脱胎于之前存在的技术。也就是说，他们一定连接于、繁殖于某种之前的技术。换句话说，进化需要遗传机制–某种连接现在与过去的细致联系。</p></li><li><p>技术在某种程度上一定是来自此前已有技术的新的组合</p></li><li><p>如果新技术真是以前技术的组合,那么现存技术的储备一定在某种程度上提供了组合的成分</p></li><li><p>组合进化:之前的技术形式被作为现在原创技术的组分,当代的新技术成为构建更新的技术的可能的组分.反过来,其中的部分集数将继续编程那些尚未实现的新技术的可能的构建.慢慢的,最初很简单的技术发展出越来越多的技术性是,而很复杂的技术往往用很简单的技术作为其组分.所有技术的集合自力更生地从无到有,从简单到复杂地成长起来了.我们可以从自身创生了自身.这种机制便是组合进化(combinational evolution).</p></li><li><p>那么这些元初地技术(ur-technology)是从何而来的呢?由此我们将现如无穷的回溯之中.一定有超出组合之外地某些东西在继续创造新的技术.</p></li><li><p>技术的构建不仅来自已有技术的组合,还来自于对自然现象的捕捉和征服.</p></li><li><p>这里有个视角的变化,要从将技术看作是有固定目的的独立客体转换到将技术看作是可以无限构成新组合的客体.</p></li></ul><h2 id="第二章-组合与结构"><a href="#第二章-组合与结构" class="headerlink" title="第二章 组合与结构"></a>第二章 组合与结构</h2><ul><li>技术的三个定义: </li></ul><ol><li><p>技术是实现人的目的的一种手段</p></li><li><p>技术是实践和元器件(components)的集成(assemblage)</p></li><li><p>技术是在某种文化中得以运用的装置和工程实践的集合</p></li></ol><ul><li><p>技术是实现目的的一种手段,它是一种装置,一种方法或一个流程</p></li><li><p>技术提供功能(functionality),功能指技术要执行的某一类任务</p></li><li><p>技术包含一系列操作,我们可以称之为技术的”软件”.这些操作需要物理设备去执行,我们可以称之为技术的”硬件”.实际上这两个方面都属于技术,但如果只强调一个方面,而忽视另一面,则会使他们看起来好像分属两个范畴,而这只是从不同侧面看待技术的结果.</p></li></ul><p>###　技术结构的形成</p><p>*　技术的最基本结构，包含一个用来执行基本功能的主机成和一套支持这一集成的次集成．</p>]]></content>
      
      
      <categories>
          
          <category> 诗书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Writing</title>
      <link href="/2020/02/25/english-writing/"/>
      <url>/2020/02/25/english-writing/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction-to-Academic-Writing-and-Editing"><a href="#Introduction-to-Academic-Writing-and-Editing" class="headerlink" title="Introduction to Academic Writing and Editing"></a>Introduction to Academic Writing and Editing</h2><p>What to write, how to write, and how to edit to imporve your document</p><h2 id="To-become-a-good-writer"><a href="#To-become-a-good-writer" class="headerlink" title="To become a good writer"></a>To become a good writer</h2><ul><li><p>Have something important to say.</p></li><li><p>Follow basic principles of English grammar in your writing.</p></li><li><p>Edit and revise. Edit and revise. Edit and revise….</p></li><li><p>Practice!</p></li></ul><h2 id="Section-1-What-to-write"><a href="#Section-1-What-to-write" class="headerlink" title="Section 1: What to write"></a>Section 1: What to write</h2><ul><li><p>Planning what to write</p></li><li><p>The writing process</p></li><li><p>The components of an academic paper</p></li></ul><h2 id="Section-2-Academic-Style"><a href="#Section-2-Academic-Style" class="headerlink" title="Section 2:Academic Style"></a>Section 2:Academic Style</h2><ul><li><p>Reference the work of others</p></li><li><p>Approaches for articles and proposals</p></li></ul><h2 id="Section-3-Editing-for-Correctness-Clarity-and-Conciseness"><a href="#Section-3-Editing-for-Correctness-Clarity-and-Conciseness" class="headerlink" title="Section 3:Editing for Correctness, Clarity, and Conciseness"></a>Section 3:Editing for Correctness, Clarity, and Conciseness</h2><ul><li><p>Grammar and punctuation principles</p></li><li><p>Writing in active voice</p></li><li><p>How to edit effectively</p></li><li><p>Writing clearly and concisely</p></li></ul><h2 id="Section-4-Tools"><a href="#Section-4-Tools" class="headerlink" title="Section 4:Tools"></a>Section 4:Tools</h2><ul><li><p>Microsoft Word -Track Changes</p></li><li><p>Useful websites and resources</p></li><li><p>More examples and exercises to help you evaluate and improve your writing and editing.</p></li></ul><h2 id="The-key-to-good-academic-writing"><a href="#The-key-to-good-academic-writing" class="headerlink" title="The key to good academic writing"></a>The key to good academic writing</h2><p>Have something to say, and say it clearly!</p><hr><h2 id="Fact-1-Paper-Structure-结构"><a href="#Fact-1-Paper-Structure-结构" class="headerlink" title="Fact 1 Paper Structure 结构"></a>Fact 1 Paper Structure 结构</h2><ul><li><p>题目</p></li><li><p>摘要</p></li><li><p>引言/文献总数</p></li><li><p>研究方法</p></li><li><p>结果/讨论</p></li><li><p>结论</p></li><li><p>参考文献</p></li></ul><h2 id="Fact-2-Review-Process"><a href="#Fact-2-Review-Process" class="headerlink" title="Fact 2 Review Process"></a>Fact 2 Review Process</h2><ul><li><p>作者</p></li><li><p>Admin 管理员</p></li><li><p>EIC主编</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之代10代理</title>
      <link href="/2020/02/08/pa-chong-zhi-dai-10-dai-li/"/>
      <url>/2020/02/08/pa-chong-zhi-dai-10-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>服务器检测的是某个IP单位时间的请求次数<br>代理即代理服务器(proxy server)<br>本机不是直接向web服务器发送请求，而是向代理服务器发送请求，再转发给服务器。并把服务器的响应转发给本机</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>1.突破自身IP限制<br>2.访问一些单位或团体内部资源<br>3.提高访问速度，代理服务器会设置一个较大的硬盘缓冲区<br>4.隐藏真实IP</p><h1 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h1><h2 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h2><p>FTP代理服务器<br>HTTP.SSL/TLS.RTSP.Telnet.POP3/SMTP.SOCKET</p><h2 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h2><p>高度匿名代理:数据包原封不动转发，服务器以为是普通客户端但其实为代理IP<br>普通匿名代理：数据包做改动，服务器端会发现代理IP，并会追查到真实IP<br>透明代理：数据包改动，且告诉服务器真实IP<br>间谍代理：用于记录用户传输的数据，进行研究，监控</p><h1 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h1><p>免费代理：可用代理不多，需要筛选，也可以维护一个代理池<br>付费代理<br>ADSL拨号：拨一次号换一次IP</p><h1 id="代理池"><a href="#代理池" class="headerlink" title="代理池"></a>代理池</h1><pre><code>from bs4 import BeautifulSoupimport requestsimport jsonheaders = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&#39;}#从xicidaili首页获取一个代理ipdef get_ip_list(url, headers):    #得到该页面的所有IP    html = requests.get(url, headers=headers)    html_text = html.text    #得到网页响应    soup = BeautifulSoup(html_text, &#39;lxml&#39;)    #解析网页    ips = soup.find_all(&#39;tr&#39;)    ip_list = []    for i in range(1, len(ips)):        ip_info = ips[i]        tds = ip_info.find_all(&#39;td&#39;)    #一个tr中的所有td        #httptype=str.lower(tds[5].text)  # HTTP/TTPS--&gt;http/https        #ip_list.append(httptype+&#39;://&#39;+tds[1].text + &#39;:&#39; + tds[2].text) #构造一个链接        ip_list.append(tds[1].text + &#39;:&#39; + tds[2].text) #得到ip:port    return ip_list#构建格式化的单个proxiesdef get_proxy(ip_port):    proxy_ip = &#39;http://&#39; + ip_port    proxy_ips = &#39;https://&#39; + ip_port    proxies = {&#39;https&#39;: proxy_ips, &#39;http&#39;: proxy_ip}    return proxiesdef verify_proxies(proxies):    http_url = &quot;https://www.mzitu.com/&quot;    try:        r=requests.get(http_url,proxies=proxies)    except Exception as e:        print(&#39;invalid \n&#39;,e)        return False    else:        if r.status_code&gt;=200 and r.status_code&lt;=300:            print(&quot;{0}valid\n &quot;.format(proxies))            return True        else:            print(&quot;{0}invalid\n&quot;.format(proxies))            return Falseif __name__ == &#39;__main__&#39;:    url = &#39;http://www.xicidaili.com/nn/&#39;    ip_list = get_ip_list(url, headers=headers)    valid_proxies_list=[]    for i in range(1,len(ip_list)):        proxies = get_proxy(ip_list[i])        verify = verify_proxies(proxies)        if verify == True:            valid_proxies_list.append(proxies)            with open(&#39;valid_proxies_list.json&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;) as file:                file.write(json.dumps(valid_proxies_list,indent=2,ensure_ascii=False))</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之9Ajax</title>
      <link href="/2020/02/08/pa-chong-zhi-9ajax/"/>
      <url>/2020/02/08/pa-chong-zhi-9ajax/</url>
      
        <content type="html"><![CDATA[<h3 id="Ajax-Asynchronous-JavaScript-and-XML-（异步的JavaScript和XML）"><a href="#Ajax-Asynchronous-JavaScript-and-XML-（异步的JavaScript和XML）" class="headerlink" title="Ajax (Asynchronous JavaScript and XML)（异步的JavaScript和XML）"></a>Ajax (Asynchronous JavaScript and XML)（异步的JavaScript和XML）</h3><p>不是一门编程语言，而是利用JavaScript在保证页面不刷新，页面链接不改变情况下与服务器交换数据并更新部分网页的技术</p><p>原始HTML的某些数据通过Ajax加载，或JavaScript处理，得到了新的页面数据<br>在这个过程中，页面实际上是在后台与服务器进行了数据交换，获取数据后，利用JavaScript改变网页，这样网页内容就会更新。例如刷微博</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>发送请求<br>解析内容<br>渲染网页</p><pre><code>var xmlhttp;if(window.XMLHttpRequest){    xmlhttp = new XMLHttpRequest();             #新建XMLHttpRequest对象}else{    xmlhttp = new ActiveObject(&#39;Microsoft.XMLHttp&#39;);}xmlhttp.onreadystatechange = function(){    #调用onreadystatechange属性进行监听，当服务器返回响应，对应的方法就会触发    if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200){        documetn.getElementById(&#39;myDiv&#39;).innerHTML = xmlhttp.responseText;        #得到响应内容，将ID为myDiv的节点内部HTML进行替换    }}xmlhttp.open(&quot;POST&quot;,&quot;/ajax/&quot;,true);           xmlhttp.send()       #向服务器发送链接                     </code></pre><h4 id="Ajax分析方法"><a href="#Ajax分析方法" class="headerlink" title="Ajax分析方法"></a>Ajax分析方法</h4><ol><li>查看请求</li></ol><p>F12开发者工具-</p><ul><li><p>Elements选项卡:<br>  查看网页的源代码</p></li><li><p>Network选项卡:<br>  页面加载过程中浏览器与服务器之间发送请求与接收响应的记录</p><p>  xhr(XMLHttpRequest)类型</p></li><li><p>Headers选项卡:</p><pre><code>  Requests Headers: X-Requested-With:XMLHttpRequest</code></pre></li><li><p>Preview选项卡:</p><p>  可以看到响应内容，JSON格式</p></li><li><p>Response选项卡：</p><p>  从中观察到真实的返回数据</p></li></ul><ol start="2"><li>过滤请求<br>筛选栏XHR,得到所有Ajax请求，随意点开一个条目，可以清楚看到其Request URL,Reuqest Headers,Response Headers,Response Body等</li></ol><h4 id="Ajax结果提取"><a href="#Ajax结果提取" class="headerlink" title="Ajax结果提取"></a>Ajax结果提取</h4><ol><li>在Headers，分析请求链接，得到变化的参数</li><li>在Preview，观察响应内容</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之8多进程</title>
      <link href="/2020/02/08/pa-chong-zhi-8-duo-jin-cheng/"/>
      <url>/2020/02/08/pa-chong-zhi-8-duo-jin-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次， 但是fork()调用一次，返回两次</p><p>因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回 子进程永远返回0，而父进程返回子进程的ID</p><p>这样做的理由是，一个父进程可以fork出很多子进程， 所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p><p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务</p><h2 id="multiprocessing模块"><a href="#multiprocessing模块" class="headerlink" title="multiprocessing模块"></a>multiprocessing模块</h2><p>提供了一个Process类来代表一个进程对象</p><pre><code>from multiprocessing import Processimport os#子进程要执行的代码def proc(name):    print(&quot;运行子进程 %s为(%s)&quot; %(name,os.getpid()))if __name__ ==&quot;__main__&quot;:    print(&quot;运行父进程 %s&quot; % os.getpid())    p = Process(target=proc, args=(&#39;test&#39;,))    print(&quot;子进程将开始&quot;)    p.start()    p.join()    print(&quot;子进程结束&quot;)</code></pre><h2 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h2><p> 进程池的方式批量创建子进程</p><pre><code> from multiprocessing import Pool# 创建进程池pool = Pool()# 第一个参数是函数，第二个参数是一个迭代器，将迭代器中的数字作为参数依次传入函数中pool.map(main, [i*10 for i in range(10)])</code></pre><pre><code>from multiprocessing import Poolimport osimport timeimport randomdef long_time_task(name):    print(&quot;运行任务%s (%s)&quot; %(name,os.getpid()))    start_time = time.time()    time.sleep(random.random()*3)    end_time = time.time()    print(&quot;任务%s运行 %f秒&quot; %(name,(end_time-start_time)))if __name__ ==&quot;__main__&quot;:          p = Pool(4)          for i in range(5):              p.apply_async(func=long_time_task,args=(i,))          print(&quot;等待所有的子进程结束&quot;)          p.close()          p.join()          print(&quot;所有的子进程结束&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之7多线程</title>
      <link href="/2020/02/08/pa-chong-zhi-7-duo-xian-cheng/"/>
      <url>/2020/02/08/pa-chong-zhi-7-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>import threading<br>创建一个活动函数<br>threading.Thread(target = 函数名,args = (a,b))</p><pre><code>from time import ctimeimport threading#自定义函数coding()def coding(language):    for i in range(5):        print(&quot;I\&#39;m coding &quot;,language,&quot; program at &quot;,ctime() )#自定义函数music()def music():    for i in range(5):        print(&quot;I\&#39;m listening music at &quot;,ctime())if __name__ == &quot;__main__&quot;:    print(&quot;线程%s在运行...&quot; % threading.current_thread().name)    thread_list = []    #创建线程    t1 = threading.Thread(target = coding,args=(&#39;python&#39;,))    #args=(3),会认为是一个数字 args=(3,) 会认为是一个元组    t2 = threading.Thread(target = music)    thread_list.append(t1)    thread_list.append(t2)    for t in thread_list:        t.setDaemon(True) #设置为守护线程        #当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；        #如果还有一个或以上的非守护线程则不会退出        #等待主线程运行完毕后销毁        t.start() #执行线程        t.join() # 在子线程运次结束之前，主线程被阻塞    print(&quot;线程%s停止!&quot; % threading.current_thread().name)</code></pre><h2 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h2><p>对共享变量，需要加锁<br>多线程，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生</p><pre><code>import threading sum = 0lock = threading.Lock()  #创建一个锁#自定义函数def put_money(money):    global sum   #全局变量，可共享    sum = sum+moneydef get_money(money):    global sum   #全局变量，可共享    sum = sum-moneydef cunqu(money):    lock.acquire() # 改动1.. 先要获取锁    try:        for i in range(1000000):  #执行次数必须足够多，才能体现出特点来            #先存再取，钱数应该为0            put_money(money)            get_money(money)    except:        lock.release()  # 改动2..别忘了释放锁:t1 = threading.Thread(target=cunqu,args=(500,))t2 = threading.Thread(target=cunqu,args=(1000,))t1.start()t2.start()t1.join()t2.join()print(sum)</code></pre><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><pre><code>from threading import Threadimport time #继承 threading.Thread类class Eat(Thread):    def __init__(self,name):        super().__init__()        self.name = name    #功能实现        def run(self):        time.sleep(2)        print(&#39;%s is eating &#39;%self.name)if __name__ == &#39;__main__&#39;:    t = Eat(&#39;ff&#39;)    t.start()    print(&#39;🐷&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之6Selenium</title>
      <link href="/2020/02/08/pa-chong-zhi-6selenium/"/>
      <url>/2020/02/08/pa-chong-zhi-6selenium/</url>
      
        <content type="html"><![CDATA[<h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><p>自动化测试工具，支持多种浏览器，<br>爬虫中主要用来解决JavaScript渲染的问题·</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre><code>from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitbrowser = webdriver.Edge()try:    browser.get(&quot;https://www.baidu.com&quot;)    input = browser.find_element_by_id(&#39;kw&#39;)    input.send_keys(&#39;Python&#39;)    input.send_keys(Keys.ENTER)    wait = WebDriverWait(browser,10)    wait.until(EC.presence_of_element_located((By.ID,&#39;content_left&#39;)))    print(browser.current_url)    print(&quot;\n&quot;)    print(browser.get_cookies)    print(&quot;\n&quot;)    print(browser.page_source)finally:    browser.close()</code></pre><h2 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h2><pre><code>from selenium import webdriverbrowser = webdriver.Edge()browser = webdriver.Chrome()browser = webdriver.Safari()</code></pre><h2 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h2><pre><code>from selenium import webdriverbrowser=webdriver.Edge()browser.get(&quot;https://www.taobao.com&quot;)print(browser.page_source)browser.close()</code></pre><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><h3 id="单个元素"><a href="#单个元素" class="headerlink" title="单个元素"></a>单个元素</h3><p>find_element_by_id(id)<br>find_element_by_name(name)<br>find_element_by_xpath(xpath)<br>find_element_by_link_text(link_text)<br>find_element_by_partial_link_text(link_text)<br>find_element_by_tag_name(name)<br>find_element_by_class_name(name)<br>find_element_by_css_selector(css_selector)</p><pre><code>from selenium import webdriverbrowser=webdriver.Edge()browser.get(&quot;https://www.taobao.com&quot;)input_first=browser.find_element_by_id(&#39;q&#39;)input_second=browser.find_element_by_css_selector(&#39;#q&#39;)print(input_first,&quot;\n&quot;,input_second)browser.close()</code></pre><pre><code>from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser=webdriver.Edge()browser.get(&quot;https://www.taobao.com&quot;)input_first=browser.find_element_by_id(&#39;q&#39;)print(input_first)browser.close()</code></pre><h3 id="多个元素"><a href="#多个元素" class="headerlink" title="多个元素"></a>多个元素</h3><p>find_elements_by_id(id)<br>find_elements_by_name(name)<br>find_elements_by_xpath(xpath)<br>find_elements_by_link_text(link_text)<br>find_elements_by_partial_link_text(link_text)<br>find_elements_by_tag_name(name)<br>find_elements_by_class_name(name)<br>find_elements_by_css_selector(css_selector)</p><pre><code>from selenium import webdriverbrowser=webdriver.Edge()browser.get(&quot;https://www.taobao.com&quot;)list=browser.find_elements(By.CSS_SELECTOR,&#39;.service-bd li&#39;)for li in list:    print(li)    print(&quot;\n&quot;)browser.close()</code></pre><h2 id="获取元素信息"><a href="#获取元素信息" class="headerlink" title="获取元素信息"></a>获取元素信息</h2><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p><img src="en-resource://database/5638:1" alt="50ce3c9ce444a2bc349ab074ffd527dd.png"></p><pre><code>from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser=webdriver.Edge()url=&#39;https://www.zhihu.com/explore&#39;browser.get(url)logo=browser.find_element_by_id(&#39;zh-top-link-logo&#39;)print(logo)print(logo.get_attribute(&#39;class&#39;))</code></pre><h3 id="获取文本值"><a href="#获取文本值" class="headerlink" title="获取文本值"></a>获取文本值</h3><p><img src="en-resource://database/5640:1" alt="4f23433f2a2fbda57bfa8047ab6a6fd5.png"></p><pre><code>from selenium import webdriverbrowser=webdriver.Edge()url=&#39;https://www.zhihu.com/explore&#39;browser.get(url)input=browser.find_element_by_class_name(&#39;zu-top-add-question&#39;)print(input.text)</code></pre><h3 id="获取ID-位置-标签名-大小"><a href="#获取ID-位置-标签名-大小" class="headerlink" title="获取ID 位置 标签名 大小"></a>获取ID 位置 标签名 大小</h3><pre><code>from selenium import webdriverbrowser=webdriver.Edge()url=&#39;https://www.zhihu.com/explore&#39;browser.get(url)input=browser.find_element_by_class_name(&#39;zu-top-add-question&#39;)print(input.id)print(input.location)print(input.tag_name)print(input.size)</code></pre><h2 id="元素交互操作"><a href="#元素交互操作" class="headerlink" title="元素交互操作"></a>元素交互操作</h2><p><img src="en-resource://database/5636:1" alt="859854106ae735de2381b2aa59f373ea.png"></p><pre><code>from selenium import webdriverimport timebrowser = webdriver.Edge()browser.get(&quot;https://www.taobao.com&quot;)input=browser.find_element_by_id(&#39;q&#39;)input.send_keys(&#39;iphone&#39;)time.sleep(1)input.clear()input.send_keys(&#39;surface&#39;)button=browser.find_element_by_class_name(&#39;btn-search&#39;)button.click()</code></pre><h2 id="执行JavaScript"><a href="#执行JavaScript" class="headerlink" title="执行JavaScript"></a>执行JavaScript</h2><pre><code>from selenium import webdriverbrowser=webdriver.Edge()browser.get(&quot;http://www.zhihu.com/explore&quot;)browser.execute_script(&#39;window.scrollTo(0,document.body.scrollHeight)&#39;)browser.execute_script(&#39;alert(&quot;To Bottom&quot;)&#39;)</code></pre><h2 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h2><p><img src="en-resource://database/5642:1" alt="86922b0c8564e32ec7d2dcac3b965999.png"></p><pre><code>import timefrom selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionbrowser=webdriver.Edge()url=&#39;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#39;browser.get(url)browser.switch_to.frame(&#39;iframeResult&#39;)source=browser.find_element_by_css_selector(&#39;#draggable&#39;)print(source)try:    logo=browser.find_element_by_class_name(&#39;logo&#39;)except NoSuchElementException:    print(&#39;NoLogo&#39;)browser.switch_to.parent_frame()logo=browser.find_element_by_class_name(&#39;logo&#39;)print(logo)print(logo.text)</code></pre><h2 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h2><p>如果WebDriver没有立即在DOM中找到元素，将继续等待一段时间再查找DOM，找不到则抛出异常</p><pre><code>from selenium import webdriverbrowser=webdriver.Edge()browser.implicitly_wait(10)browser.get(&quot;https://www.zhihu.com/explore&quot;)input=browser.find_element_by_class_name(&quot;zu-top-add-question&quot;)print(input)</code></pre><h2 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h2><pre><code>from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECbrowser=webdriver.Edge()browser.get(&quot;https://www.taobao.com&quot;)wait=WebDriverWait(browser,10)input = wait.until(EC.presence_of_element_located((By.ID,&#39;q&#39;)))button= wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR,&#39;.btn-search&#39;)))print(input,&#39;\n&#39;,button)</code></pre><h2 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h2><pre><code>import timefrom selenium import webdriverbrowser=webdriver.Edge()browser.get(&quot;https://www.taobao.com/&quot;)browser.get(&quot;https://www.baidu.com/&quot;)browser.get(&quot;https://www.zhihu.com/&quot;)browser.back()time.sleep(1)browser.forward()browser.close()</code></pre><h2 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h2><pre><code>import time from selenium import webdriverbrowser = webdriver.Edge()browser.get(&quot;https://www.baidu.com&quot;)browser.execute_script(&#39;window.open()&#39;)print(browser.window_handles)browser.switch_to_window(browser.window_handles[1])browser.get(&quot;https://www.taobao.com&quot;)time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get(&quot;https://www.zhihu.com&quot;)</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>from selenium import webdriverbrowser=webdriver.Edge()try:    browser.get(&quot;https://www.baidu.com&quot;)except TimeoutException:    print(&quot;Time Out&quot;)try:    browser.find_element_by_id(&quot;hello&quot;)except NoSuchElementException:    print(&quot;No Element&quot;)finally:    browser.close()</code></pre><h2 id="下拉选择框select处理"><a href="#下拉选择框select处理" class="headerlink" title="下拉选择框select处理"></a>下拉选择框select处理</h2><pre><code>&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;selenium 处理 下拉框&lt;/title&gt; &lt;/head&gt; &lt;body bgcolor=&quot;#f0f8ff&quot;&gt;  &lt;h3 align=&quot;center&quot;&gt;selenium下拉框处理方法&lt;/h3&gt;  &lt;hr/&gt;  &lt;td align=&quot;center&quot;&gt;下拉框demo&lt;/td&gt;  &lt;br/&gt; &lt;select id=&quot;selectdemo&quot; class=&quot;select&quot; name=&quot;selectdemo&quot;&gt; &lt;option name=&quot;jiaolian&quot; value=&quot;210101&quot; selected=&quot;selected&quot;&gt;教练人员&lt;/option&gt;  &lt;option name=&quot;pingpang&quot; value=&quot;210102&quot;&gt;乒乓球球员&lt;/option&gt;  &lt;option name=&quot;lanqiu&quot; value=&quot;210103 &quot;&gt;篮球运动员&lt;/option&gt;  &lt;option name=&quot;zuqiu&quot; value=&quot;210103  &quot;&gt;足球运动员&lt;/option&gt;  &lt;option name=&quot;youyong&quot; value=&quot;210402&quot;&gt;游泳运动员&lt;/option&gt;  &lt;option name=&quot;tiaoshui&quot; value=&quot;210403&quot;&gt;跳水运动员&lt;/option&gt;  &lt;/select&gt;  &lt;/body&gt;  &lt;/html&gt;</code></pre><h3 id="1-使用Webdriver提供的Select类的方法"><a href="#1-使用Webdriver提供的Select类的方法" class="headerlink" title="1.使用Webdriver提供的Select类的方法"></a>1.使用Webdriver提供的Select类的方法</h3><pre><code>from selenium.webdriver.support.select import Selectselect_by_value(value)select_by_index(index)select_by_visible_text(text)</code></pre><pre><code>选择篮球运动员选项# 实例化一个Select类的对象 selector = Select(driver.find_element_by_id(&quot;selectdemo&quot;)) # 下面三种方法用于选择&quot;篮球运动员&quot; selector.select_by_index(&quot;2&quot;) # 通过index进行选择,index从0开始 selector.select_by_value(&quot;210103&quot;) # 通过value属性值进行选择 selector.select_by_visible_text(&quot;篮球运动员&quot;) # 通过标签显示的text进行选择</code></pre><h3 id="2-先定位select-然后在定位option"><a href="#2-先定位select-然后在定位option" class="headerlink" title="2. 先定位select 然后在定位option"></a>2. 先定位select 然后在定位option</h3><pre><code># 定位到下拉选择框 selector = driver.find_element_by_id(&quot;selectdemo&quot;) # selector = driver.find_element_by_xpath(&quot;.//*[@id=&#39;selectdemo&#39;]&quot;) # 选择&quot;篮球运动员&quot; selector.find_element_by_xpath(&quot;//option[@value=&#39;210103&#39;]&quot;).click() # selector.find_elements_by_tag_name(&quot;option&quot;)[2].click()</code></pre><h3 id="3-直接通过xpath层级标签定位"><a href="#3-直接通过xpath层级标签定位" class="headerlink" title="3.直接通过xpath层级标签定位"></a>3.直接通过xpath层级标签定位</h3><pre><code>driver.find_element_by_xpath(&quot;.//*[@id=&#39;selectdemo&#39;]/option[3]&quot;).click()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之3Request</title>
      <link href="/2020/02/07/pa-chong-zhi-3request/"/>
      <url>/2020/02/07/pa-chong-zhi-3request/</url>
      
        <content type="html"><![CDATA[<h1 id="Requests"><a href="#Requests" class="headerlink" title="Requests:"></a>Requests:</h1><p>基于urllib</p><h2 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h2><pre><code>import requestsresponse = requests.get(&quot;https://www.baidu.com&quot;)print(response)print(response.status_code)print(response.text)print(response.cookies)</code></pre><h2 id="各种请求方式"><a href="#各种请求方式" class="headerlink" title="各种请求方式"></a>各种请求方式</h2><pre><code>import requestsresponse = requests.get(&quot;https://www.baidu.com&quot;)print(type(response))print(response.status_code)print(type(response.text))print(response.text)print(response.cookies)</code></pre><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><pre><code>import requestsresponse= requests.get(&quot;http://httpbin.org/get&quot;)print(response.text)</code></pre><pre><code>import requestsdata = {    &#39;name&#39;:&#39;germey&#39;,    &#39;age&#39;:22    }response=requests.get(&quot;http://httpbin.org/get&quot;,params=data)print(response.text)</code></pre><p>添加headers</p><pre><code>import requestsheaders={    &#39;User-Agent&#39;:&#39;Mozilla/5.0&#39;}response=requests.get(&quot;https://www.zhihu.com/explore&quot;,headers=headers)print(response.text)</code></pre><h2 id="解析json"><a href="#解析json" class="headerlink" title="解析json"></a>解析json</h2><pre><code>import requestsimport jsonresponse = requests.get(&quot;http://httpbin.org/get&quot;)print(response.text)print(response.json())print(json.loads(response.text))</code></pre><h2 id="获取二进制数据"><a href="#获取二进制数据" class="headerlink" title="获取二进制数据"></a>获取二进制数据</h2><pre><code>import requestsresponse=requests.get(&quot;https://github.com/favicon.ico&quot;)print(response.text)print(response.content)</code></pre><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>response 响应</p><pre><code>import requestsresponse = requests.get(&#39;http://www.jianshu.com&#39;)print(response.status_code)print(response.headers)print(response.cookies)print(response.url)print(response.history)</code></pre><p>状态码判断</p><pre><code>import requestsresponse = requests.get(&#39;http://www.jianshu.com&#39;)exit()if not response.status_code==200 else print(&#39;Request Successfully&#39;)</code></pre><p>代理设置</p><pre><code>import requestsproxies={    &#39;http&#39;:&#39;socks5//127.0.0.1:9743&#39;,    &#39;https&#39;:&#39;socks5://127.0.0.9743&#39;}reponse=requests.get(&quot;https://www.taobao.com&quot;,proxies=proxies)print(&quot;response.statu_code&quot;)</code></pre><p>证书验证</p><pre><code>import requestsresponse = requests.get(&quot;https://www.12306.cn&quot;,verify=False)print(response.status_code)</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>import requestsfrom requests.exceptions import ReadTimeout,HTTPError,RequestExceptiontry:    response=requests.get(&#39;http://httpbin.org/get&#39;,timeout=0.1)    print(response.status_code)except ReadTimeout:    print(&#39;timeout&#39;)except HTTPError:    print(&#39;http error&#39;)except RequestException:    print(&#39;Error&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之5BeautifulSoup</title>
      <link href="/2020/02/07/pa-chong-zhi-5beautifulsoup/"/>
      <url>/2020/02/07/pa-chong-zhi-5beautifulsoup/</url>
      
        <content type="html"><![CDATA[<h1 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h1><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库、执行速度适中 、文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前的版本中文容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快、文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>lxml XML 解析器</td><td>BeautifulSoup(markup, “xml”)</td><td>速度快、唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre><code>html = &quot;&quot;&quot;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;            &lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;        &lt;/p&gt;        &lt;p class=&quot;story&quot;&gt;            Once upon a time there were three little sisters; and their names were            &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;            &lt;!-- Elsie --&gt;            &lt;/a&gt;,            &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;            Lacie            &lt;/a&gt;             and            &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;             Tillie            &lt;/a&gt;;            and they lived at the bottom of a well.        &lt;/p&gt;        &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup)   # bs4.BeautifulSoupprint(soup.title)  # 标签 bs4.element.Tagprint(soup.title.name) #标签的名称#print(soup.p.attrs[&#39;name&#39;])  #标签的属性print(soup.p.text)  #标签的文字内容print(soup.p.get_text()) #标签的文字内容print(soup.head.title.string) #标签的文字内容 bs4.element.NavigableString</code></pre><h2 id="子节点和子孙节点"><a href="#子节点和子孙节点" class="headerlink" title="子节点和子孙节点"></a>子节点和子孙节点</h2><ul><li>.contents 返回一个列表，包含所有子节点（文字，标签，换行符，空格等）</li><li>.children 返回子节点迭代对象（文字，标签，换行符，空格等），需要遍历输出</li><li>.descendants 返回子孙节点的迭代对象（文字，标签，换行符，空格等），需要遍历输出</li><li>enumerate() 枚举某个对象</li></ul><pre><code>print(soup.p.contents) #返回所有子节点（文字，标签，换行符，空格等）print(soup.p.children) #list_iterator objectprint(type(soup.p.children)) for  i,child in enumerate(soup.p.children):    print(i,child) print(soup.p.descendants)for i, child in enumerate(soup.p.descendants):    print(i, child)</code></pre><h2 id="父节点和祖先节点"><a href="#父节点和祖先节点" class="headerlink" title="父节点和祖先节点"></a>父节点和祖先节点</h2><ul><li>.parent #返回父亲节点（文字，标签，换行符，空格等）</li><li>.parents #返回所有祖先节点（文字，标签，换行符，空格等）,需要遍历输出</li></ul><pre><code>print(soup.a.parent)print(soup.a.parents)for i,parent in enumerate(soup.a.parents):    print(i,parent)</code></pre><h2 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h2><ul><li>.next_siblings 后面的所有兄弟节点（文字内容，子标签，换行符，空格等）</li><li>.previous_siblings 前面的所有兄弟节点（文字内容，子标签，换行符，空格等）</li></ul><pre><code>print(soup.a.next_siblings)for i,next in enumerate(soup.a.next_siblings):    print(i,next)print(&quot;\n&quot;)   print(soup.a.previous_siblings)for i,pre in enumerate(soup.a.previous_siblings):    print(i,pre)</code></pre><h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><h6 id="find-all-name-attrs-recursive-text-kwargs"><a href="#find-all-name-attrs-recursive-text-kwargs" class="headerlink" title="find_all(name,attrs,recursive,text,**kwargs)"></a>find_all(name,attrs,recursive,text,**kwargs)</h6><h6 id="find-name-attrs-recursive-text-kwargs"><a href="#find-name-attrs-recursive-text-kwargs" class="headerlink" title="find( name , attrs , recursive , text , **kwargs )"></a>find( name , attrs , recursive , text , **kwargs )</h6><p>根据名称，属性，文字内容查找</p><pre><code>html=&#39;&#39;&#39;&lt;div class=&quot;panel&quot;&gt;    &lt;div class=&quot;panel-heading&quot;&gt;        &lt;h4&gt;Hello&lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;panel-body&quot;&gt;        &lt;ul class=&quot;list&quot; id=&quot;list-1&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Jay&lt;/li&gt;        &lt;/ul&gt;        &lt;ul class=&quot;list list-small&quot; id=&quot;list-2&quot;&gt;            &lt;li class=&quot;element&quot;&gt;Foo&lt;/li&gt;            &lt;li class=&quot;element&quot;&gt;Bar&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;&#39;&#39;&#39;</code></pre><h6 id="利用名称"><a href="#利用名称" class="headerlink" title="利用名称"></a>利用名称</h6><pre><code>from bs4 import BeautifulSoupsoup = BeautifulSoup(html, &#39;lxml&#39;)print(soup.find_all(&#39;ul&#39;))  #bs4.element.ResultSetprint(soup.find_all(&#39;ul&#39;)[0]) #bs4.element.Tagfor u in soup.find_all(&#39;ul&#39;):    print(u)</code></pre><h6 id="利用属性"><a href="#利用属性" class="headerlink" title="利用属性"></a>利用属性</h6><pre><code>print(soup.find_all(attrs={&#39;id&#39;: &#39;list-1&#39;}))   bs4.element.ResultSetprint(soup.find_all(id=&#39;list-1&#39;))  #简写print(soup.find_all(&#39;ul&#39;,class_=&#39;list&#39;))print(soup.find_all(class_=&#39;element&#39;))</code></pre><h6 id="利用文本"><a href="#利用文本" class="headerlink" title="利用文本"></a>利用文本</h6><pre><code>print(soup.find_all(text=&#39;Foo&#39;))</code></pre><h6 id="find-parents"><a href="#find-parents" class="headerlink" title="find_parents()"></a>find_parents()</h6><p>返回所有祖先节点</p><h6 id="find-parent"><a href="#find-parent" class="headerlink" title="find_parent()"></a>find_parent()</h6><p>返回直接父节点</p><h6 id="find-next-siblings"><a href="#find-next-siblings" class="headerlink" title="find_next_siblings()"></a>find_next_siblings()</h6><p>返回后面所有兄弟节点  </p><h6 id="find-next-sibling"><a href="#find-next-sibling" class="headerlink" title="find_next_sibling()"></a>find_next_sibling()</h6><p>返回后面第一个兄弟节点</p><h6 id="find-previous-siblings"><a href="#find-previous-siblings" class="headerlink" title="find_previous_siblings()"></a>find_previous_siblings()</h6><p>返回前面所有兄弟节点  </p><h6 id="find-previous-sibling"><a href="#find-previous-sibling" class="headerlink" title="find_previous_sibling()"></a>find_previous_sibling()</h6><p>返回前面第一个兄弟节点</p><h6 id="find-all-next"><a href="#find-all-next" class="headerlink" title="find_all_next()"></a>find_all_next()</h6><p>返回节点后所有符合条件的节点  </p><h6 id="find-next"><a href="#find-next" class="headerlink" title="find_next()"></a>find_next()</h6><p>返回第一个符合条件的节点</p><h6 id="find-all-previous"><a href="#find-all-previous" class="headerlink" title="find_all_previous()"></a>find_all_previous()</h6><p>返回节点后所有符合条件的节点 </p><h6 id="find-previous"><a href="#find-previous" class="headerlink" title="find_previous()"></a>find_previous()</h6><p>返回第一个符合条件的节点</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之4正则表达式</title>
      <link href="/2020/02/07/pa-chong-zhi-4-zheng-ze-biao-da-shi/"/>
      <url>/2020/02/07/pa-chong-zhi-4-zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>非python独有，re模块实现</p><h6 id="位置："><a href="#位置：" class="headerlink" title="位置："></a>位置：</h6><p>^匹配字符串开头<br>$匹配字符串末尾<br>()匹配括号内表达式</p><h6 id="字符："><a href="#字符：" class="headerlink" title="字符："></a>字符：</h6><p>\w匹配<strong>字母</strong> <strong>数字</strong> <strong>下划线</strong><br>\d匹配<strong>任意数字</strong><br>\s匹配<strong>空白字符</strong><br>.匹配<strong>任意字符(除换行符)</strong></p><h6 id="次数："><a href="#次数：" class="headerlink" title="次数："></a>次数：</h6><p>{n}精准匹配n次<br>？匹配0次或1次<br>+匹配至少一个<br>*匹配至少0个</p><h2 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h2><pre><code>re.match(pattern,string,flags=0)</code></pre><p>从字符串的开头匹配给定的模式，若该字符串不匹配，则返回none</p><pre><code>import recontent = &quot;hello 123 4567 world_this is a regex demo&quot;print(len(content))result=re.match(&#39;^hello\s\d\d\d\s\d{4}\s\w{10}.*demo$&#39;,content)print(result)print(result.group())print(result.span())</code></pre><h2 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h2><p>从字符串的开头匹配给定的模式，并返回第一个成功的匹配</p><pre><code>import recontent = &quot;extra strings hello 1234567 world_this is a regex demo&quot;result=re.search(&#39;hello.*?(\d+).*?demo$&#39;,content)print(result)</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>为匹配方便，能用search就不用match</p><h2 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall()"></a>re.findall()</h2><p>从字符串开头匹配给定的模式，以列表形式返回所有匹配</p><h2 id="re-sub"><a href="#re-sub" class="headerlink" title="re.sub()"></a>re.sub()</h2><p>替换字符串中每一个匹配的子串后返回替换后的字符串</p><pre><code>import recontent = &#39;extra strings hello 1234567 world_this is a regex demo&#39;content=re.sub(&#39;\d+&#39;,&#39;&#39;,content)print(content)</code></pre><h2 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile()"></a>re.compile()</h2><p>将正则字符串编译成正则表达式对象</p><pre><code>import recontent=&#39;hello 1234567 world_this is a regex demo&#39;pattern=re.compile(&#39;hello.*demo&#39;,re.S)result=re.match(pattern,content)print(result)</code></pre><h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>.匹配任意字符（除换行符）<br><em>匹配至少0个字符<br>.\</em> 匹配最长的</p><pre><code>import recontent = &quot;hello 1234567 world_this is a regex demo&quot;result=re.match(&#39;^he.*(\d+).*demo$&#39;,content)print(result)print(result.group())print(result.span())</code></pre><h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><p>.匹配任意字符（除换行符）<br>*匹配至少0个字符<br>?匹配0个或1个<br>.*? 匹配最短的</p><pre><code>import recontent = &quot;hello 1234567 world_this is a regex demo&quot;result=re.match(&#39;^he.*?(\d+).*demo$&#39;,content)print(result)print(result.group())print(result.span())</code></pre><h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><p>re.S 将\n作为普通的字符加入到字符串中<br>group(1) 返回第一组</p><pre><code>import recontent = &#39;&#39;&#39;hello 1234567 world_thisis a regex demo&#39;&#39;&#39;result=re.match(&#39;^he.*?(\d+).*?demo$&#39;,content,re.S)print(result)print(result.group(1))</code></pre><h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><p>尽量使用非贪婪匹配，有换行符就用re.S</p><h2 id="匹配演练"><a href="#匹配演练" class="headerlink" title="匹配演练"></a>匹配演练</h2><pre><code>import rehtml=&#39;&#39;&#39;&lt;div id=songs-list&gt;    &lt;h2 class=&#39;title&#39;&gt;经典老歌&lt;\h2&gt;    &lt;p class=&#39;introduction&#39;&gt;经典老歌列表&lt;/p&gt;    &lt;ul id=&quot;list&quot; class=&quot;list-group&quot;&gt;        &lt;li data-view=&quot;1&quot;&gt;一路上有你&lt;/li&gt;        &lt;li data-view=&quot;2&quot;&gt;            &lt;a href=&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;沧海一声笑&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;3&quot; class=&#39;active&#39;&gt;            &lt;a href=&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;往事随风&lt;/a&gt;        &lt;/li&gt;        &lt;li data-view=&quot;4&quot;&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;5&quot;&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;陈慧琳&quot;&gt;记事本&lt;/a&gt;&lt;/li&gt;        &lt;li data-view=&quot;6&quot;&gt;&lt;a href=&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt;但愿人长久&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;/div&gt;&#39;&#39;&#39;result = re.search(&#39;&lt;li.*?active.*?singer=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&#39;,html,re.S)if result:    print(result.group(1),result.group(2))</code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之2第三方库</title>
      <link href="/2020/02/07/pa-chong-zhi-2-di-san-fang-ku/"/>
      <url>/2020/02/07/pa-chong-zhi-2-di-san-fang-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><ol><li>urllib库 </li><li>re库 （默认安装）</li><li>requests库</li><li>selenium库</li><li>beautifulsoup4库</li><li>pyquery库</li><li>pymysql库</li><li>pymongo库</li><li>redis库</li><li>flask库<h1 id="清华镜像"><a href="#清华镜像" class="headerlink" title="清华镜像"></a>清华镜像</h1></li></ol><p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a> requests</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫之1基础</title>
      <link href="/2020/02/07/pa-chong-zhi-1-ji-chu/"/>
      <url>/2020/02/07/pa-chong-zhi-1-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;今天将学习过的爬虫学习笔记整理一下~</p><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><ol><li><p>发送请求: 发送一个Request，请求包含额外的headers等信息，等待服务器的响应</p></li><li><p>获取响应内容：得到Response，可能是HTML，JSON字符串，二进制数据（图片 视频））</p></li><li><p>解析内容：内容可能是HTML，用正则表达式，网页解析库。可能是JSON，转换为JSON对象解析。可能是二进制数据，做保存或进一步处理</p></li><li><p>保存数据：保存为文本，或数据库</p></li></ol><h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><p>浏览器发送消息给服务器 </p><ol><li>Request Method：<br>GET(请求参数在url网址里)<br>POST(构建表单，提交表单才能请求)</li><li>请求URL </li><li>请求头（accept host cookie user-agent） </li><li>请求体</li></ol><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><p>服务器处理请求，回传消息 </p><ol><li>响应状态 :200 404  </li><li>响应头：Response Headers </li><li>响应体（网页源代码）<br>(network选项卡,每条记录是请求与相应记录，Headers是请求头，Preview是网页的源代码，浏览器进行解析)</li></ol><h1 id="能抓怎样的数据？"><a href="#能抓怎样的数据？" class="headerlink" title="能抓怎样的数据？"></a>能抓怎样的数据？</h1><ul><li>文本(HTML文档 JSON文本)</li><li>二进制文件（图片，视频）</li></ul><h1 id="怎样解析？"><a href="#怎样解析？" class="headerlink" title="怎样解析？"></a>怎样解析？</h1><ol><li>直接处理 </li><li>Json解析 </li><li>正则表达式 </li><li>BeautifulSoup </li><li>PyQuery </li><li>XPath</li></ol><h1 id="为什么我抓取的和网页不同？"><a href="#为什么我抓取的和网页不同？" class="headerlink" title="为什么我抓取的和网页不同？"></a>为什么我抓取的和网页不同？</h1><p>JS运行，调用后台接口，拿到的新数据</p><h1 id="怎么解决JavaScript渲染的问题？"><a href="#怎么解决JavaScript渲染的问题？" class="headerlink" title="怎么解决JavaScript渲染的问题？"></a>怎么解决JavaScript渲染的问题？</h1><ol><li>分析Ajax请求 </li><li>用Selenium webdriver库驱动浏览器加载网页，模拟JavaScript渲染 </li><li>用Splash库模拟JavaScript渲染</li></ol><h1 id="怎样保存数据？"><a href="#怎样保存数据？" class="headerlink" title="怎样保存数据？"></a>怎样保存数据？</h1><ol><li>文本 </li><li>关系型数据库 MySql </li><li>非关系型数据库 MongoDB  Redis等Key-Value形式存储 </li><li>二进制文件，如图片，视频</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之支撑向量机</title>
      <link href="/2020/02/04/ji-qi-xue-xi-zhi-zhi-cheng-xiang-liang-ji/"/>
      <url>/2020/02/04/ji-qi-xue-xi-zhi-zhi-cheng-xiang-liang-ji/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;今天接着整理支撑向量机的学习笔记。<br>&ensp;&ensp;支撑向量机，简称SVM(Support Vector Machine),可以用来解决分类问题，同样也可以解决回归问题。特别是在分类问题中，如果各个分类样本的决策边界不唯一，可以用于解决不适定问题。<br><a href="https://imgchr.com/i/1DWLL9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/04/1DWLL9.md.png" alt="1DWLL9.md.png"></a></p><p>&ensp;&ensp;我们在做分类时，需要找到一个决策边界，不仅要将现有的训练数据的各个类别进行划分，还要有很好的泛化能力，对未来的测试数据也要能够很好的划分，要离我们的各个分类样本尽可能的远。即距离两个类别的最近的样本最远。这些最近的样本点称为支撑向量。对于这样的线性可分的问题，称为Hard Margin SVM。而线性不可分的问题，则称为Soft Margin SVM。如下图所示<br><a href="https://imgchr.com/i/1DW8PK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/04/1DW8PK.md.png" alt="1DW8PK.md.png"></a><br>因为$$margin = 2d$$,所以，SVM就是要最大化margin，即最大化d。</p><p>&ensp;&ensp;我们在高中学过点$(x,y)$到直线$Ax+By+C=0$的距离公式为<br>$$\frac{|Ax+By+c|}{\sqrt{A^{2}+B^{2}}}$$。如果我们拓展到n维空间，直线方程为$$\theta^{T}*x_{b}=0$$,其中$\theta_{0}x_{0}$为截距b，则换一种形式为$$w^{T}x+b=0$$</p><p>&ensp;&ensp;假设决策边界$w^{T}x+b=0$,则点$(x,y)$到决策边界的距离为<br>$$\frac{|W^{T}x+b|}{|w|}$$<br>其中$|w|=\sqrt{w_{1}^{2}+w_{2}^{2}+…+w_{n}^{2}}$</p><p>&ensp;&ensp;支撑向量到决策边界的距离为d，其余样本点到决策边界的距离均大于d，所以<br>$$\begin{cases} \frac{|W^{T}x^{i}+b|}{|w|}&gt;=d&amp;\forall y^{i}=1\\ \frac{|W^{T}x^{i}+b|}{|w|}&lt;=-d&amp;\forall y^{i}=-1\end{cases} $$<br>即<br>$$\begin{cases} \frac{|W^{T}x^{i}+b|}{|w|d}&gt;=1&amp;\forall y^{i}=1\\ \frac{|W^{T}x^{i}+b|}{|w|d}&lt;=-1&amp;\forall y^{i}=-1\end{cases} $$<br>即<br>$$\begin{cases} |W_{d}^{T}x^{i}+b_{d}&gt;=1&amp;\forall y^{i}=1\\ W_{d}^{T}x^{i}+b_{d}&lt;=-1&amp;\forall y^{i}=-1\end{cases} $$</p><p>决策边界与支撑边界的变化如下图所示<br><img src="https://s2.ax1x.com/2020/02/04/1DcY0x.png" alt="1DcY0x.png"><br><img src="https://s2.ax1x.com/2020/02/04/1Dc09e.png" alt="1Dc09e.png"><br><img src="https://s2.ax1x.com/2020/02/04/1DcatO.png" alt="1DcatO.png"></p><p>$$\therefore y^{i}(w^{T}x^{i}+b)&gt;=1$$</p><p>&ensp;&ensp;而对于任意的支撑向量x，我们要最大化margin，最大化d，<br>$$\therefore max \frac{w^{T}x+b}{|w|}$$，<br>$$\therefore max \frac{1}{|w|}$$，<br>$$\therefore min |w|$$<br>$$\therefore min \frac{1}{2}w^{2}$$</p><p>&ensp;&ensp;最终我们得到，在$$y^{i}(w^{T}x^{i}+b)&gt;=1$$的条件下，我们要$$min \frac{1}{2}w^{2}$$</p><p>&ensp;&ensp;我们来看下Soft Margin 和SVM的正则化。我们需要我们的SVM能够有一定的容错能力，因此支撑边界为$w^{T}x+b=1-\delta$，但也要保证容错能力尽可能小，所以我们要使得$$min\frac{1}{2}(|w|)^{2}+\sum_{i=1}^{m}\delta_{i}$$，$$\delta_{i}&gt;=0$$，这样也可以确保$\delta$足够小。<br>如下图所示。<br><a href="https://imgchr.com/i/1DcB1H" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/04/1DcB1H.md.png" alt="1DcB1H.md.png"></a></p><p>&ensp;&ensp;对于Soft Margin SVM，我们可以使用前面所学习过的正则化，来最小化目标函数。如<br>|L1正则  |L2正则  |<br>|—|—|<br>| $min\frac{1}{2}(|w|)^{2}+C\sum_{i=1}^{m}\delta_{i}$ | $min\frac{1}{2}(|w|)^{2}+C\sum_{i=1}^{m}\delta_{i}^{2}$ |<br>其中都要保证$y^{i}(w^{T}x^{i}+b)&gt;=1-\delta_{i}$，且$\delta_{i}&gt;=0$</p><p>&ensp;&ensp;实际使用SVM，和KNN一样，要做数据标准化处理！因为涉及计算距离，如果数据点在不同的维度上的量纲不同，则在计算距离时造成一定的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之逻辑回归</title>
      <link href="/2020/02/04/ji-qi-xue-xi-zhi-luo-ji-hui-gui/"/>
      <url>/2020/02/04/ji-qi-xue-xi-zhi-luo-ji-hui-gui/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;国家目前正全力打赢这场”疫情攻防战”，我老实的呆在家里学习，不给祖国添乱，便是对国家最大的贡献。趁着寒假这段时间，将逻辑回归的学习笔记整理如下！</p><h3 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h3><p>&ensp;&ensp;逻辑回归用以解决分类问题，但是回归怎么能够解决分类问题呢?原来是逻辑回归将样本的特征和样本发生的概率联系起来，而样本发生的概率是一个数，所以其是一个回归问题。</p><p>&ensp;&ensp;我们知道机器学习的本质是$y^{‘}=f(x)$，根据给出的样本值得到预测值$y^{‘}$。而在逻辑回归中，则是<br>$$p^{‘}=f(x)$$<br>$$<br>y^{‘}=\begin{cases} 1,p^{‘}&gt;=0.5\\0,p^{‘}&lt;0.5<br>\end{cases}<br>$$<br>根据给出的样本值得到一个概率，根据概率值确定预测值$y^{‘}$。</p><p>&ensp;&ensp;因此逻辑回归既可以看作回归算法，也可以看作是分类算法，但通常作为分类算法用，只可以解决二分类问题。</p><p>&ensp;&ensp;在线性回归中的$y^{‘}=f(x)$ 其实是<br>$$y^{‘}=\theta^{T}.x_{b}$$<br>其值域范围为$(-\infty,+\infty)$。而逻辑回归中的值域范围为(-1,1)，因此，逻辑回归的$y^{‘}=f(x)$ 其实是$$p^{‘}=\sigma(\theta^{T}.x_{b})$$<br>其中$\sigma$是sigmoid函数，即$$\sigma(t)=\frac{1}{1+e^{-t}}$$相当于神经网络中的激活函数。<br><a href="https://imgchr.com/i/1BrQjP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/04/1BrQjP.md.png" alt="1BrQjP.md.png"></a><br>因此，逻辑回归的模型为$$p^{‘}=\sigma(\theta^{T}.x_{b})=\frac{1}{1+e^{-\theta^{T}.x_{b}}}$$<br>$y^{‘}=\begin{cases}1,p^{‘}&gt;=0.5\\0,p^{‘}&lt;0.5 \end{cases}$</p><p>&ensp;&ensp;那么在逻辑回归中，对于给定的样本数据集$X,y(真实值)$，我们该如何找到参数$\theta$，使得最大程度的获得样本数据集X对应的分类输出y？即使得逻辑回归的损失函数值最小呢？</p><h3 id="逻辑回归的损失函数"><a href="#逻辑回归的损失函数" class="headerlink" title="逻辑回归的损失函数"></a>逻辑回归的损失函数</h3><p>&ensp;&ensp;根据逻辑回归的模型，我们可以得到<br>$$cost = \begin{cases} 如果y=1,p^{‘}越小，cost越大\\如果y=0,p^{‘}越大，cost越大 \end{cases}$$<br>因为如果真实值y=1,概率值越小，预测值$y^{‘}$越接近于0，则损失值cost越大。反之，如果真实值y=0,概率值越大，预测值$y^{‘}$越接近于1，则损失值cost越大。</p><p>&ensp;&ensp;而对于此类损失函数，我们可以想到log函数正好符合这样的特性。即<br>$$cost = \begin{cases}-log(p^{‘})&amp;if&amp;y=1 \-log(1-p^{‘})&amp;if&amp;y=0 \end{cases}$$<br>他们的函数图像如下所示：<br><a href="https://imgchr.com/i/1Br3B8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/04/1Br3B8.md.png" alt="1Br3B8.md.png"></a><br>综上，逻辑回归的损失函数为<br>$$cost = -ylog(p^{‘}-(1-y)log(1-p^{‘}))$$</p><p>即<br>$$J(\theta)=-\frac{1}{m}\sum_{i=1}^{m}y^{i}log(p^{‘i})+(1-y^{i})log(1-p^{‘i}))$$<br>其中<br>$$p^{‘i}=\sigma(X_{b}^{i}\theta)=\frac{1}{1+e^{-X_{b}^{i}\theta}}$$</p><p>&ensp;&ensp;对于逻辑回归的损失函数，我们可以通过梯度下降法求解它的最小值，不过我们需要利用高中所学的求导公式进行求导(比较麻烦，就先省略了)，最后他的导数为<br>$$\nabla J(\theta) = \frac{1}{m}X_{b}^{T}(\sigma(X_{b}\theta)-y)$$</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之多项式回归</title>
      <link href="/2020/01/31/ji-qi-xue-xi-zhi-duo-xiang-shi-hui-gui/"/>
      <url>/2020/01/31/ji-qi-xue-xi-zhi-duo-xiang-shi-hui-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><p>&ensp;&ensp;寒假期间，我来将多项式回归算法的笔记整理一下。</p><p>&ensp;&ensp;多项式回归算法主要用来处理非线性数据。如果我们想要拟合非线性数据，如$y=ax^2+bx+c$,我们可以将$x^2$作为一个特征，$x$作为另一个特征，即可当作线性回归进行处理，相当于为样本多添加了一些特征(原来样本的多项式项)</p><p>&ensp;&ensp;在sklearn中，如果原样本有$x_{1},x_{2}$两个特征，调用多项式回归算法时，PolynomiaFeature(degree=2)(<strong>多项式特征</strong>)会产生如下特征:1,$x_{1}^{1}$,$x_{2}^{1}$,$x_{1}^{2}$,$x_{2}^{2}$。如果degree=3，则产生如下特征:1,$x_{1}^{1}$,$x_{2}^{1}$,$x_{1}^{2}$,$x_{2}^{2}$,$x_{1}<em>x_{2}$,$x_{1}^{3}$,$x_{2}^{3}$,$x_{1}^{2}</em>x_{1}$,$x_{1}*x_{2}^{2}$。</p><p>&ensp;&ensp;degree越高，拟合的效果越好，产生overfitting过拟合，算法所训练的模型过多的表达了数据间的噪音关系。如果非线性数据使用线性回归算法，则会造成underfitting欠拟合，算法所训练的模型不能完整的表述数据间的关系。</p><p>&ensp;&ensp;而随着模型复杂度的提高，训练数据集上模型准确率会越来越高，测试数据集上，模型准确率会先高后低，出现过拟合。为了防止模型出现过拟合或者欠拟合，我们需要将数据分为训练数据集和测试数据集，训练数据集用以训练模型，测试数据集用以评估模型的泛化能力。</p><hr><p>&ensp;&ensp;随着训练样本的增多，模型的表现能力(误差的变化、稳定值的变化)有怎样的变化？变化的曲线则为learning-curve学习曲线。</p><hr><p>&ensp;&ensp;但如果模型对特定的测试数据集出现过拟合该怎么办呢？因此，我们可以将数据分为训练数据集、验证数据集、测试数据集。训练数据集用以训练数据，验证数据集用以评判模型，调整超参数，测试数据集作为衡量最终模型性能的数据集。</p><p>&ensp;&ensp;此时，我们可以使用cross-valiadition交叉验证。<br><a href="https://imgchr.com/i/18tLKU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/01/18tLKU.md.png" alt="18tLKU.md.png"></a><br><a href="https://imgchr.com/i/18tbvT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/01/18tbvT.md.png" alt="18tbvT.md.png"></a><br><a href="https://imgchr.com/i/18tH2V" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/01/18tH2V.md.png" alt="18tH2V.md.png"></a></p><hr><p>&ensp;&ensp;针对模型出现的误差，我们肯定是希望误差越小越好。但这需要我们采用一些小技巧和付出一些努力！一般认为模型误差=偏差(Bias)+方差(Variance)+不可避免地误差。偏差和方差如下图所示。<br><a href="https://imgchr.com/i/18tXb4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/01/18tXb4.md.png" alt="18tXb4.md.png"></a></p><p>&ensp;&ensp;其中预测的问题本身是靶子中心，拟合的模型则是打出的枪。左下角是高偏差(很明显模型的结果都偏于靶心),右上角是高方差(很明显模型的结果都分散于靶心周围)。导致偏差的主要原因是对于问题本身的假设不正确，如非线性数据使用线性回归，造成underfitting。导致方差的主要原因是模型没有学习到问题的本质，而学习到很多的噪音，如模型太复杂，使用高阶多项式回归，造成overfitting。</p><p>&ensp;&ensp;有一些算法天生是高方差算法，如KNN，其高度依赖于样本数据，不依赖于参数，有一些算法天生是高偏差算法，如线性回归。</p><p>&ensp;&ensp;非参数学习的算法通常都是高方差的算法，因为不对数据假设,只能根据现有的训练数据进行预测，特别依赖现有的训练数据的准确度。参数学习通常都是高偏差算法，因为，将整个问题归结为一个数学模型，求出该模型相应的参数即可，对数据具有极强的假设。</p><p>&ensp;&ensp;大多数算法具有相应的参数，可以调整偏差和方差。如KNN中的k，k越小，模型越复杂，偏差越小。k越大，模型越简单，直到等于样本总数时，knn样本中谁最多则预测谁，则偏差最大，方差最小。再比如使用多项式回归，degree越大，模型越复杂，偏差越小，方差越大，degree越小，接近1，模型越简单，偏差越大。降低偏差，会提高方差，降低方差，则会提高偏差。而机器学习的主要挑战，来自于方差。</p><p>&ensp;&ensp;为了解决高方差，我们有以下手段：<br>1、 降低模型复杂度<br>2、 减少数据维度，降噪（减少对噪声的学习），如PCA<br>3、 增加样本数<br>4、 使用验证集<br>5、 模型正则化</p><p>&ensp;&ensp;这里着重说一下模型正则化Regularization，正则化是要约束参数的大小。那到底会怎么约束呢，且看下文！</p><p>&ensp;&ensp;我们知道线性回归的目标是<br>$$\sum_{i=1}^{m}(y^{i}-\theta_{0}-\theta_{1}x_{1}^{i}-\theta_{2}x_{2}^{i})-…\theta_{n}x_{n}^{i}$$<br>尽可能小，对于损失函数，则<br>$$J(\theta)=MSE(y,y^{‘};\theta)$$<br>尽可能小。加入模型正则化后，则<br>$$J(\theta)=MSE(y,y^{‘};\theta)+\alpha*\frac{1}{2}\sum_{i=1}^{m}\theta_{i}^{2}$$<br>尽可能小。此时加入的模型正则化为Ridge Regression岭回归。</p><p>&ensp;&ensp;为了让$J(\theta)$尽可能小，则必须考虑让每一个$\theta$尽可能小。甚至会让某些$\theta$值为0。正好减少数据特征，减少模型的高方差。</p><p>&ensp;&ensp;除了Ridge Regression外，还有LASSO Regression(least Absolute Shrinkage and <strong>Selection</strong> Operator Regression)，加入LASSO Regression后，则使得<br>$$J(\theta)=MSE(y,y^{‘};\theta)+\alpha*\sum_{i=1}^{m}|\theta_{i}|$$<br>尽可能小。LASSO趋向于使得一部分$\theta$值变为0，所以可作为特征选择用。</p><p>&ensp;&ensp;我们注意到，$\alpha$是一个新的超参数，为0时，则相当于没有正则化，当正无穷时，则MSE的比重很小，只有当每一个$\theta$都接近于0时，则会让$J(\theta)$尽可能小。</p><hr><p>&ensp;&ensp;现在我们将学习到的距离公式，误差函数，正则化整理一下，会发现他们之间是有规律和联系的。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Ridge(L2范数、L2正则化)</td><td>MSE</td><td>欧拉距离</td></tr><tr><td>$|x|_{2} = \frac{1}{2}\sum_{i=1}^{m}\theta_{i}^{2}$</td><td>$\frac{1}{n}\sum_{i=1}^{m}(y_{i}-y_{i}^{‘})^{2}$</td><td>$(\sum_{i=1}^{m}(x_{i}^{1}-x_{i}^{2})^{2})^{\frac{1}{2}}$</td></tr><tr><td>LASSO(L1范数、L1正则化)</td><td>MAE</td><td>曼哈顿距离</td></tr><tr><td>$|x|_{1} = \sum_{i=1}^{m}|\theta_{i}|$</td><td>$\frac{1}{n}\sum_{i=1}^{m}|y_{i}-y_{i}^{‘}|$</td><td>$\sum_{i=1}^{m}|x_{i}^{1}-x_{i}^{2}|$</td></tr><tr><td>范数</td><td></td><td>明可夫斯基距离</td></tr><tr><td>$|x|_{p} = (\sum_{i=1}^{m}|x_{i}|^{p})^{\frac{1}{p}}$</td><td></td><td>($\sum_{i=1}^{m}(x_{i}^{1}-x_{i}^{2})^{p})^{\frac{1}{p}}$</td></tr></tbody></table><p>&ensp;&ensp;总之，各种回归或者正则，都是给MSE添加正则项，形成新的损失函数。最后，还有一种正则化，名之弹性网，则结合两种方式，并引入一个新的超参数r，来表示两种正则项的比例。<br>$$J(\theta) = MSE(y,y^{‘};\theta)+r*\alpha\sum_{i=1}^{m}|\theta_{i}| + (1-r) \frac{1}{2}\alpha\sum_{i=1}^{m}(\theta_{i})^{2}$$</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCI论文写作与发表</title>
      <link href="/2020/01/19/lun-wen-xie-zuo-yu-fa-biao/"/>
      <url>/2020/01/19/lun-wen-xie-zuo-yu-fa-biao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇笔记内容摘自《SCI论文写作和发表：You Can Do It》</p></blockquote><h4 id="如何写好一篇稿件"><a href="#如何写好一篇稿件" class="headerlink" title="如何写好一篇稿件"></a>如何写好一篇稿件</h4><ol><li>列提纲</li></ol><ul><li>为什么要做这个研究</li><li>如何来做实验</li><li>实验结果是什么</li><li>实验结果的意义</li></ul><p>2.全面的查文献（查证自己的科研是否解决了一个文献上没有解决的问题）</p><p>3.充实稿件内容，完成草稿</p><p>4.修改内容（找导师、朋友帮忙修改，提意见。内容不需要改动后，再集中精力修改文法）</p><p>5.修改英语</p><ul><li>内容是否完整，思路和段落是否合理，段落之间是否要调整顺序</li><li>句子是否通顺，句子与句子之间是否有合理的连接</li><li>用字是否准确，全文用词是否一致，字词输入是否有错，标点符号的使用，文献索引等</li></ul><h4 id="审稿人评价稿件标准"><a href="#审稿人评价稿件标准" class="headerlink" title="审稿人评价稿件标准"></a>审稿人评价稿件标准</h4><ul><li><p>Do the research and the results present a significant new advance to a clearly identified technological problem or scientific question?</p></li><li><p>研究和结果是否为技术问题或科学问题带来了重大的新进展？</p></li><li><p>Are the objectives of the research clearly defined, and is the research in line with the objectives?</p></li><li><p>研究目标是否明确的定义，研究是否与目标一致？</p></li><li><p>Is the introduction clearly presented, and confined to the research objective?</p></li><li><p>引言是否清楚地提出，并仅限于研究目的？</p></li><li><p>Are the experimental methods appropriate, and are they described clearly and with sufficient details for the work to be repeatable?</p></li><li><p>实验方法是否适当，是否对它们进行了清晰，详细的描述，以确保工作可重复？</p></li><li><p>Are the data quantitative, understandable, and presented clearly?</p></li><li><p>数据是否定量，易于理解并清晰呈现？</p></li><li><p>Is the satistical treatment of the data adequate?</p></li><li><p>对数据的统计处理是否足够？</p></li><li><p>Are the results and conclusions clearly presented and do they support the claims made by the authors?</p></li><li><p>结果和结论是否清楚陈述，是否支持作者的主张？</p></li><li><p>Is the discussion integrated with the results, clearly presented and confined to hte research data?</p></li><li><p>讨论是否与结果结合在一起，清楚地提出并仅限于研究数据？</p></li><li><p>Are the language, grammar, and style of high standard?</p></li><li><p>语言，语法和样式是否高标准？</p></li><li><p>Are the figures and tables of high quality?</p></li><li><p>数字和表格是否高质量？</p></li><li><p>Does the title adequately reflect the content of the manuscript?</p></li><li><p>标题是否充分反映了手稿的内容？</p></li><li><p>Can the abstract be understood on its own and does it contain the relevant facts?</p></li><li><p>摘要能否被单独理解，并且包含相关事实吗？</p></li><li><p>Are the most relevant references all cited , can unnecessary or marginally relevant references be omitted?</p></li><li><p>是否引用了所有最相关的参考文献，可以省略不必要的或勉强相关的参考文献吗？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>语法</title>
      <link href="/2020/01/19/yu-fa/"/>
      <url>/2020/01/19/yu-fa/</url>
      
        <content type="html"><![CDATA[<h4 id="词性"><a href="#词性" class="headerlink" title="词性"></a>词性</h4><ul><li>名词</li><li>代词</li><li>动名词</li><li>不定式</li><li>动词</li><li>形容词</li><li>副词</li><li>现在分词</li><li>过去分词(类动词)</li><li>介宾短语</li><li>数词</li><li>限定词</li></ul><h4 id="句子成分"><a href="#句子成分" class="headerlink" title="句子成分"></a>句子成分</h4><ul><li><p>主语(名词、代词、动名词、不定式、数词)</p></li><li><p>宾语(名词、代词、动名词、不定式、数词)</p></li><li><p>谓语(动词)</p></li><li><p>表语(名词、不定式、形容词、现在分词、过去分词、介宾短语)</p></li><li><p>补语(名词、不定式、形容词、现在分词、过去分词、介宾短语)</p></li><li><p>定语(名词、代词、形容词、现在分词、过去分词、介宾短语、数词)</p></li><li><p>状语(代词、不定式、副词、现在分词、过去分词、介宾短语)</p></li><li><p>同位语(名词、代词、动名词)</p></li></ul><h4 id="单句"><a href="#单句" class="headerlink" title="单句"></a>单句</h4><ul><li><p>主 谓 宾</p></li><li><p>主 谓 宾 宾补</p></li><li><p>主 谓 间宾 直宾</p></li><li><p>被动语态</p></li><li><p>主 不及物动词</p></li><li><p>主 系 表</p></li><li><p>there be</p></li><li><p>it充当形式主语</p></li></ul><h4 id="从句"><a href="#从句" class="headerlink" title="从句"></a>从句</h4><ul><li><p>主语从句</p></li><li><p>名词性从句</p></li><li><p>状语从句</p></li><li><p>定语从句</p></li><li><p>表语从句</p></li></ul><h4 id="语法问题"><a href="#语法问题" class="headerlink" title="语法问题"></a>语法问题</h4><h5 id="冠词"><a href="#冠词" class="headerlink" title="冠词"></a>冠词</h5><ul><li><p>可数名词前要加冠词</p><p>  I need to read a book about how to combat crime.</p></li><li><p>不可数名词不用冠词，除非特指</p><p>  Education is important to one’s job prospect.</p></li><li><p>形容词前加定冠词</p><p>  the only<br>  the same<br>  the main</p></li><li><p>序数词和形容词最高级加定冠词</p><p>  the twentieth<br>  the most common</p></li></ul><h5 id="谓语使用"><a href="#谓语使用" class="headerlink" title="谓语使用"></a>谓语使用</h5><ul><li><p>主谓一致</p><p>  动名词/不定式作主语，谓语动词为单数<br>  不可数名词作主语，谓语动词为单数<br>  代词后谓语动词为单数<br>  由what，whether，how,that,where引发的主语从句，谓语动词为单数<br>  … of … 的词组，谓语动词与of之前的名词一致<br>  主语后跟with，together with，coupled with，combined with，as well as，谓语随主语变化<br>  there be句型谓语动词随主语变化</p></li></ul><h5 id="助动词使用"><a href="#助动词使用" class="headerlink" title="助动词使用"></a>助动词使用</h5><table><thead><tr><th></th><th>一般时态</th><th>进行时态</th><th>完成时态</th><th>完成进行时态</th></tr></thead><tbody><tr><td>过去</td><td>speak/speaks</td><td>am/is/are speaking</td><td>have/has spoken</td><td>have/has been speaking</td></tr><tr><td>现在</td><td>spoken</td><td>was/were speaking</td><td>had spoken</td><td>had been speaking</td></tr><tr><td>将来</td><td>will speak</td><td>will be speaking</td><td>will have spoken</td><td>will have been speaking</td></tr><tr><td>过去将来</td><td>should speak</td><td>should be speaking</td><td>should have spoken</td><td>should have been speaking</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 英文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>词伙</title>
      <link href="/2020/01/18/ci-huo/"/>
      <url>/2020/01/18/ci-huo/</url>
      
        <content type="html"><![CDATA[<hr><p>a better quality of life<br>更好的生活质量</p><p>a bricks and motar college<br>实体学院</p><p>a budget surplus<br>预算盈余</p><p>a conservative attitude towards<br>对…的保守态度</p><p>a correctional method<br>矫正方法</p><p>a firm grounding<br>坚实的基础</p><p>a fulfilling career<br>有成就的事业</p><p>a global language<br>全球性的语言</p><p>a good command<br>好的掌控力</p><p>a good job prospect<br>良好的工作前景</p><p>a long prison term<br>长期监禁</p><p>a moral compass<br>道德指南</p><p>a peaceful, closely-knit society<br>一个和平，团结的社会</p><p>a positive light<br>正面的角度</p><p>a rural - to - urban shift<br>从农村向城市的转变</p><p>a sense of security<br>安全感</p><p>a socially responsible way<br>对社会负责的方式</p><p>a universal language<br>童工语言</p><p>a well-educated workforce<br>有良好教育的劳动力</p><p>a world of knowledge<br>知识世界</p><p>abnormal weather<br>异常天气</p><p>abolition of tuition<br>免除学费</p><p>absorb information<br>汲取信息</p><p>academic courses<br>学术课程</p><p>academic groups<br>学术团体</p>]]></content>
      
      
      <categories>
          
          <category> 英文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Favorite Poetry</title>
      <link href="/2020/01/18/favorite-poetry/"/>
      <url>/2020/01/18/favorite-poetry/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;此文用以记载我所喜爱的诗歌，给予我勇敢向上的力量，莫要固步自封，止步不前！</p><hr><h4 id="我曾七次鄙视我的灵魂"><a href="#我曾七次鄙视我的灵魂" class="headerlink" title="我曾七次鄙视我的灵魂"></a><center>我曾七次鄙视我的灵魂</center></h4><center>纪伯伦</center><p align="left"></p><p>第一次，当它本可进取时，却故作谦卑<br>第二次，当它在空虚时，用爱欲来填充<br>第三次，在困难和容易之间，它选择了容易<br>第四次，它犯了错，却借由别人也会犯错来宽慰自己<br>第五次，它自幼软弱，却把它认为是生命的坚韧<br>第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副<br>第七次，它侧身与生活的污泥中，虽不甘心，却又畏首畏尾</p><p></p><hr><h4 id="七律-长征"><a href="#七律-长征" class="headerlink" title="七律 长征"></a><center>七律 长征</center></h4><p align="left"></p><p>红军不怕远征难，万水千山只等闲<br>五岭逶迤腾细浪，乌蒙磅礴走泥丸<br>金沙水拍云崖暖，大渡桥横铁索寒<br>更喜岷山千里雪，三军过后尽开颜</p><hr><h4 id="人生就像一列开往终点的列车"><a href="#人生就像一列开往终点的列车" class="headerlink" title="人生就像一列开往终点的列车"></a><center>人生就像一列开往终点的列车</center></h4><p align="left"></p><p>人生就像一列开往终点的列车<br>很多陌生人出现在途中<br>无数风景更是一闪而过<br>更多人却不会陪伴自己到达终点<br>坦然接受他们的离别后<br>还要感谢留下来陪伴自己的人<br>感谢你陪伴我追寻天边的理想<br>无论它多么渺茫<br>也要让它实现<br>这是我暗自许下的诺言<br>原来这个世界上还有这么一个人<br>让自己想要温柔地对待<br>我曾深深痛恨这个世界<br>直到你的出现<br>让我学会原谅之前生活对我所有的刁难<br>是你<br>让我变得坚强起来<br>从来没有想过<br>原来一个人的旅行<br>能看到比想象中更宽广更美丽的世界<br>但在你的身边<br>即使没有最宽广的世界<br>却也能收获最简单的幸福<br>至今仍然难以忘怀<br>当时你如此简单稚嫩的一句情话<br>让我高兴了好几个晚上<br>不知道命运有没有眷顾过我<br>与你的相遇<br>让我看到了这个世界最美丽的风景<br>感谢在青春最张扬的时候遇到你<br>让我的年少时光变得有意义<br>我说不出来为什么喜欢你<br>但我知道<br>你就是我不喜欢别人的理由<br>我所学会的坚强<br>不是在悲伤的时候忍住眼泪<br>而是在擦干眼泪以后<br>还能微笑地面对生活<br>在生活最艰难的时候<br>我忍耐过也努力过<br>然后它就好起来了<br>庆幸自己当初坚持了下来<br>从那天开始<br>我就给自己定下了目标<br>要努力成为与你相称的存在<br>珍惜了今天<br>珍惜了现在<br>就不用担心<br>明天是不是存在</p><p></p>]]></content>
      
      
      <categories>
          
          <category> 诗书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之决策树</title>
      <link href="/2020/01/13/ji-qi-xue-xi-zhi-jue-ce-shu/"/>
      <url>/2020/01/13/ji-qi-xue-xi-zhi-jue-ce-shu/</url>
      
        <content type="html"><![CDATA[<h4 id="sklearn建模流程"><a href="#sklearn建模流程" class="headerlink" title="sklearn建模流程"></a>sklearn建模流程</h4><ul><li>实例化，建立评估模型对象</li><li>通过模型接口训练模型</li><li>通过模型接口评估模型</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>根据数据的特征和标签总结出决策规则，并用树状图的结构来表示出来。</p><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>根节点：针对特征的判断<br>中间节点：针对特征的判断<br>叶子节点:对应具体的类别标签</p><h4 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h4><ul><li>如何从数据表中找出最佳节点和最佳分支</li><li>如何让决策树停止生长，防止过拟合</li></ul><h4 id="sklean中的决策树"><a href="#sklean中的决策树" class="headerlink" title="sklean中的决策树"></a>sklean中的决策树</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>tree.DecisionTreeClassifier</td><td>分类树</td></tr><tr><td>tree.DecisionTreeRegressor</td><td>回归树</td></tr><tr><td>tree.export_graphviz</td><td>将决策树导出为DOT格式，画图专用</td></tr><tr><td>tree.ExtraTreeClassifier</td><td>高随机版本的分类树</td></tr><tr><td>tree.ExtraTreeRegressor</td><td>高随机版本的回归树</td></tr></tbody></table><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> treeclf <span class="token operator">=</span> tree<span class="token punctuation">.</span>DecisionTreeclassfier<span class="token punctuation">(</span><span class="token punctuation">)</span>clf <span class="token operator">=</span> clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>y_train<span class="token punctuation">)</span>result <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span>y_test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="DecisionTreeClassifier"><a href="#DecisionTreeClassifier" class="headerlink" title="DecisionTreeClassifier"></a>DecisionTreeClassifier</h4><h5 id="criterion-不纯度"><a href="#criterion-不纯度" class="headerlink" title="criterion(不纯度)"></a>criterion(不纯度)</h5><p>不纯度越低，决策树对训练集的拟合越好。<br>叶子结点的不纯度一定是低于父节点。</p><p>对于不纯度的计算有两种方法</p><ul><li>信息熵(Entropy)<br>$$Entropy(t)=-\sum_{i=0}^{c-1}p(i|t)log_{2}p(i|t)$$</li><li>基尼系数(Gini Impurity)<br>$$Gini(t)=1-\sum_{i=0}^{c-1}p(i|t)^2$$</li></ul><p>其中$p(i|t)$代表分类i在节点t上所占的比例</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ul><li>计算全部特征的不纯度指标</li><li>选取不纯度指标最优的特征来分枝</li><li>在第一个特征的分枝下，计算全部特征的不纯度指标</li><li>选取不纯度指标最优的特征来分支<br>以此类推，直至没有特征可用</li></ul><p>建立一棵树</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn <span class="token keyword">import</span> tree<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_wine <span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">wine <span class="token operator">=</span> load_wine<span class="token punctuation">(</span><span class="token punctuation">)</span>wine<span class="token punctuation">.</span>datawine<span class="token punctuation">.</span>targetwine<span class="token punctuation">.</span>feature_nameswine<span class="token punctuation">.</span>target_names<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#组合数据</span><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd pd<span class="token punctuation">.</span>concat<span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>wine<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span>pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>wine<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#按照30%划分训练集与测试集</span>X_train<span class="token punctuation">,</span>X_test<span class="token punctuation">,</span>Y_train<span class="token punctuation">,</span>Y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>wine<span class="token punctuation">.</span>data<span class="token punctuation">,</span>wine<span class="token punctuation">.</span>target<span class="token punctuation">,</span>test_size <span class="token operator">=</span> <span class="token number">0.3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#实例化</span>clf <span class="token operator">=</span> tree<span class="token punctuation">.</span>DecisionTreeClassfier<span class="token punctuation">(</span>criterion<span class="token operator">=</span>'entropy<span class="token punctuation">)</span>clf <span class="token operator">=</span> clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span>Y_train<span class="token punctuation">)</span>score <span class="token operator">=</span> clf<span class="token punctuation">.</span>score<span class="token punctuation">(</span>X_test<span class="token punctuation">,</span>Y_test<span class="token punctuation">)</span>score<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#画树</span>feature_name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'酒精'</span><span class="token punctuation">,</span><span class="token string">'苹果酸'</span><span class="token punctuation">,</span><span class="token string">'灰'</span><span class="token punctuation">,</span><span class="token string">'灰的碱性'</span><span class="token punctuation">,</span><span class="token string">'镁'</span><span class="token punctuation">,</span><span class="token string">'总酚'</span><span class="token punctuation">,</span><span class="token string">'类黄酮'</span><span class="token punctuation">,</span><span class="token string">'非黄烷类酚类'</span><span class="token punctuation">,</span><span class="token string">'花青素'</span><span class="token punctuation">,</span><span class="token string">'颜色强度'</span><span class="token punctuation">,</span><span class="token string">'色调'</span><span class="token punctuation">,</span><span class="token string">'od280/od315西施葡萄酒'</span><span class="token punctuation">,</span><span class="token string">'脯氨酸'</span><span class="token punctuation">]</span><span class="token keyword">import</span> graphvizdot_data <span class="token operator">=</span> tree<span class="token punctuation">.</span>export_graphviz<span class="token punctuation">(</span>clf                                <span class="token punctuation">,</span>feature_names <span class="token operator">=</span> feature_name                                <span class="token punctuation">,</span>class_names<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'琴酒'</span><span class="token punctuation">,</span><span class="token string">'雪莉'</span><span class="token punctuation">,</span><span class="token string">'贝尔摩德'</span><span class="token punctuation">]</span>                                <span class="token punctuation">,</span>rounded<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>graph <span class="token operator">=</span> graphviz<span class="token punctuation">.</span>Source<span class="token punctuation">(</span>dot_data<span class="token punctuation">)</span>graph<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#特征重要性</span>clf <span class="token operator">=</span> feature_importances_<span class="token punctuation">[</span><span class="token operator">*</span>zip<span class="token punctuation">(</span>feature_name<span class="token punctuation">,</span>clf<span class="token punctuation">.</span>feature_importances_<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机课程与论文写作</title>
      <link href="/2020/01/12/ji-suan-ji-ke-cheng-yu-lun-wen-xie-zuo/"/>
      <url>/2020/01/12/ji-suan-ji-ke-cheng-yu-lun-wen-xie-zuo/</url>
      
        <content type="html"><![CDATA[<p>计算机的主干课程可以细分为两类，一类为硬件，一类为软件。</p><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><ul><li>微机原理 </li><li>计算机组成</li><li>计算机系统结构 等等</li></ul><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><ul><li>离散数学</li><li>编译原理</li><li>操作系统</li><li>数据结构</li><li>数据库</li><li>计算机网络 等等</li></ul><h4 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h4><ul><li><p>Title</p></li><li><p>Author</p><ul><li>name</li><li>Affiliation<ul><li>student member(学生会员)</li><li>member(会员)</li><li>senior member(高级会员)</li><li>Fellow(院士)</li></ul></li></ul></li><li><p>Abstract（点出该领域存在的问题，本文所做的工作，以及实验结果）</p></li><li><p>keywords (3-5个)</p></li><li><p>biographic (学历、现职、研究领域、身份)</p></li></ul><ol><li>Introduction<ul><li>xxx[1]提出了…，做了什么工作，该工作有什么特点，但还存在什么问题<br>聚焦本文的研究问题，本文提出了…，研究了…，设计了…<br>该工作的优点…<br>章节安排</li></ul></li><li>background（背景知识）</li><li>论文核心点1</li><li>论文核心点2</li><li>论文核心点3</li><li>实验结果分析<ul><li>提出问题（Q1、Q2、Q3）</li><li>实验过程</li><li>结果分析</li></ul></li><li>Conclusion &amp; future research direction</li><li>Acknowledgements (致谢)</li><li>Reference</li></ol><h4 id="国内部分计算机类期刊"><a href="#国内部分计算机类期刊" class="headerlink" title="国内部分计算机类期刊"></a>国内部分计算机类期刊</h4><ul><li><p>计算机学报</p></li><li><p>软件学报</p></li><li><p>计算机研究与发展</p></li><li><p>计算机科学</p></li><li><p>小型微型计算机系统</p></li><li><p>计算机工程</p></li><li><p>计算机应用与软件</p></li></ul><h4 id="大学职称"><a href="#大学职称" class="headerlink" title="大学职称"></a>大学职称</h4><ul><li><p>lecturer 讲师</p></li><li><p>assistant professor 助理教授</p></li><li><p>associate professor 副教授</p></li><li><p>part time professor 兼职教授</p></li><li><p>full time professor 全职教授</p></li><li><p>tenure 终身教授</p></li></ul><h4 id="大学行政"><a href="#大学行政" class="headerlink" title="大学行政"></a>大学行政</h4><ul><li>assistant to VP 校长助理</li><li>Director 领导(嘿嘿)</li><li>Dean 院长</li><li>vice President 副校长</li><li>President 校长</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之评价标准</title>
      <link href="/2019/12/25/ji-qi-xue-xi-zhi-ping-jie-biao-zhun/"/>
      <url>/2019/12/25/ji-qi-xue-xi-zhi-ping-jie-biao-zhun/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;哈喽，大家好，我们又见面了！我们在判断一种机器学习算法的性能好坏时，需要根据一定的评价标准。</p><p>&ensp;&ensp;对于分类算法来说，有以下标准：</p><ul><li><p>分类准确度:<br>  分类准确度是通过计算预测正确的值<code>np.sum(y_predict==y_test)</code>在实际的结果值<code>len(y_test)</code>中所占的比率。但是对于极度偏斜的数据，只用分类准确度还远远不够。</p></li><li><p>混淆矩阵(Confusion Matrix):</p><table><thead><tr><th></th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>TN</td><td>FP</td></tr><tr><td>1</td><td>FN</td><td>TP</td></tr></tbody></table><pre><code>  其中行的0、1代表真实值，列的0、1代表预测值  TN(True Negative):判定值为假，真实值与之相同  FP(False Positive):判定值为真，真实值与之相反  FN(False Negative):判定值为假，真实值与之相反  TP(True Positive):判定值为真，真实值与之相同</code></pre></li><li><p>精准率(查准率):</p></li></ul><p>$$precision = \frac{TP}{TP+FP}$$</p><pre><code>表示预测为正的样本中多少是真的样本</code></pre><ul><li>召回率(查全率):</li></ul><p>$$recall = \frac{TP}{TP+FN}$$</p><pre><code>表示样本的正例中有多少被预测正确了</code></pre><ul><li>F1 score</li></ul><p>$$\frac{1}{F1}=\frac{1}{2}(\frac{1}{precision}+\frac{1}{recall})$$<br>$$F1 = \frac{2precision*recall}{precision+recall}$$</p><pre><code>同时兼顾精准率和召回率</code></pre><ul><li><p>Precision-Recall的平衡</p></li><li><p>Precision-Recall曲线</p></li><li><p>ROC曲线(Receiver Operation characteristic Curve)</p></li></ul><p>$$TPR = \frac{TP}{TP+FN} = Recall$$<br>$$FPR = \frac{FP}{TN+FP}$$</p><pre><code>描述TPR和FPR之间的关系</code></pre><hr><p>&ensp;&ensp;我们在前面说到，我们的误差函数一般都是误差的平方，如$$ \sum_{i=1}^{m}(y_{test}^{i} - y_{test}^{‘i})^2 $$这种形式。我们还在线性回归那一节中使用最小二乘法推导了该误差函数的最小化的参数。</p><hr><p>&ensp;&ensp;我们都知道，误差函数的值越小越好，根据这个误差函数，我们又有了相似的误差函数形式。如</p><ul><li>均方误差 MSE(Mean Squared Error)</li></ul><p>$$MSE=\frac{1}{m}\sum_{i=1}^{m}(y_{test}^{i}-y_{test}^{‘i})^2$$</p><ul><li>均方根误差 RMSE(Root Mean Squared Error)</li></ul><p>$$RMSE=\sqrt{\frac{1}{m}\sum_{i=1}^{m}(y_{test}^{i}-y_{test}^{‘i})^2}=\sqrt{MSE}$$</p><ul><li>平方绝对误差 MAE(Mean Absolute Error)</li></ul><p>$$MSE=\frac{1}{m}\sum_{i=1}^{m}|y_{test}^{i}-y_{test}^{‘i}|$$</p><p>&ensp;&ensp;此外，我们还有一种回归算法评价标准</p><ul><li>$R^2$</li></ul><p>$$<br>R^2=1-\frac{SS_{residual}}{SS_{total}}<br>$$<br>$$<br>=1-\frac{\sum_{i}(y^{‘i}-y^{i})^2}{\sum_{i}(\overline{y}-y^{i})^2}<br>$$<br>$$<br>=1-\frac{\sum_{i}(y^{‘i}-y^{i})^2/m}{\sum_{i}(\overline{y}-y^{i})^2/m}<br>$$<br>$$<br>=1-\frac{MSE(y^{‘},y)}{Var(y)}<br>$$</p><p>其中$SS_{residual}$是Residual Sum of Square，$SS_{total}$是Total sum of Square。$\sum_{i}(y^{‘i}-y^{i})^2$是使用我们的模型产生的一些错误，而 $\sum_{i}(\overline{y}-y^{i})^2$是使用$y=\overline{y}$预测产生的错误，这是一个baseline model，会产生非常多的错误。如果$R^2&lt;0$，说明我们的模型还不如基准模型，因此，$R^2$越大越好，$R^2$值为1时，我们的模型则百分之百正确。</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全连接层神经网络</title>
      <link href="/2019/12/19/quan-lian-jie-ceng-shen-jing-wang-luo/"/>
      <url>/2019/12/19/quan-lian-jie-ceng-shen-jing-wang-luo/</url>
      
        <content type="html"><![CDATA[<p>最简单的神经网络就是全连接层神经网络，一般分为输入层(input_nodes)，隐藏层(hidden_nodes)，输出层(outputs_nodes)。如下图所示。<br><a href="https://imgchr.com/i/l9IayF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/24/l9IayF.md.jpg" alt="l9IayF.md.jpg"></a></p><p>针对其中的每一个节点在处理输入值与输出值时，都会通过权重矩阵和阈值函数进行处理。如下图所示。</p><p><a href="https://imgchr.com/i/lFk0de" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/25/lFk0de.md.jpg" alt="lFk0de.md.jpg"></a></p><p>我们总是说需要训练神经网络，其实说的就是调整神经网络的权重。我们定义输入层到隐藏层的权重矩阵为$W_{ih}$,隐藏层到输出层的权重矩阵为$W_{ho}$，则</p><p>$$W_{ih}=\left[ \begin{matrix}W_{11} &amp; W_{21}\\ W_{12} &amp; W_{22} \end{matrix} \right]$$</p><p>$$W_{ho}=\left[ \begin{matrix}W_{11} &amp; W_{21}\\ W_{12} &amp; W_{22} \end{matrix} \right]$$</p><p>则隐藏层的输入值为<br>$$X_{hidden}=W_{ih}<em>I$$<br>$$=W_{ih}</em> \left[ \begin{matrix} inputs_{1} \\ inputs_{2}\end{matrix} \right]$$</p><p>隐藏层的输出值为<br>$$O_{hidden}=sigmoid(X_{hidden})$$</p><p>其中的$sigmoid$函数就是一种阈值函数，可以将函数值进一步处理，满足神经网络的需求</p><p>则输出层的输入值为<br>$$X_{output}=W_{ho}*O_{hidden}$$<br>输出层的输出值为<br>$$O_{output}=sigmoid{X_{output}}$$</p><h2 id="误差怎么办"><a href="#误差怎么办" class="headerlink" title="误差怎么办"></a>误差怎么办</h2><p>在神经网络搭建好之后，刚开始输出层输出的实际值是不准确的，它与目标值有一定的差距。这其中就必然存在误差。同样的，我们可以采用在线性回归算法中使用的误差函数，即$误差函数=(目标值-实际值)^2$。</p><p>那我们该如何减小误差呢，那就是要通过BP算法(反向传播误差)来不断调整神经网络的权重值$W_{ih},W_{ho}$。如下图所示。</p><p>#未完待续!</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neural network and deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之线性回归</title>
      <link href="/2019/12/17/ji-qi-xue-xi-zhi-xian-xing-hui-gui/"/>
      <url>/2019/12/17/ji-qi-xue-xi-zhi-xian-xing-hui-gui/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;线性回归算法的思想也比较简单，可以用来解决二分类问题。</p><p>&ensp;&ensp;我们的目标是要找到一条界线$y=ax+b$,这条界线可以尽可能的区分两种属性。</p><p>&ensp;&ensp;假设在一个坐标系中有黑白两种类型的圆点，对于每一个$x^{i}$,都有一个真值$y^{i}$与之对应，但我们在寻找这条界线的过程中，对于每一个$x^{i}$,我们都有一个$y^{‘i}$，我们需要勇敢的面对这其中的损失，即$y^{i}-y^{‘i}$。</p><p>&ensp;&ensp;但这个损失有正数也有负数，不利于我们进行计算。所以，对于他们之间的损失，我们需要采用$(y^{i}-y^{‘i})^2$进行统计。如果考虑所有样本，则损失函数可以表示为$\sum_{i=1}^{m}(y^{i}-y^{‘i})^2$。</p><p>&ensp;&ensp;所以线性回归算法要解决的问题，就是要找到界线的系数$a$ $b$,使得$\sum_{i=1}^{m}(y^{i}-y^{‘i})^2$尽可能小，即最小化误差的平方。</p><p>&ensp;&ensp;我们可以采用最小二乘法来解决这个问题，如果对这个推导不感兴趣可以直接跳过。<br>设<br>$$J(a,b)$$ </p><p>$$=\sum_{i=1}^{m}(y^{i}-y^{‘i})^2$$</p><p>$$=\sum_{i=1}^{m}(y^{i}-ax^{i}-b)^2$$</p><p>现在我们要使得</p><p>$$\frac{\partial J(a,b)}{\partial a}=0$$</p><p>$$\frac{\partial J(a,b)}{\partial b}=0$$</p><p>首先我们对b求导</p><p>$$\frac{\partial J(a,b)}{\partial b}$$</p><p>$$=\sum_{i=1}^{m}2(y^{i}-ax^{i}-b)(-1)$$</p><p>$$=0$$</p><p>即</p><p>$$\sum_{i=1}^{m}(y^{i}-ax^{i}-b)=0$$</p><p>$$\sum_{i=1}^{m}y^{i}-a\sum_{i=1}^{m}x^{i}-\sum_{i=1}^{m}b=0$$</p><p>$$\sum_{i=1}^{m}y^{i}-a\sum_{i=1}^{m}x^{i}-mb=0$$</p><p>$$\sum_{i=1}^{m}y^{i}-a\sum_{i=1}^{m}x^{i}=mb$$</p><p>最终得到</p><p>$$b=\overline{y} - a\overline{x}$$</p><p>接下来我们对a求导，对a的求导比较麻烦。</p><p>$$\frac{\partial J(a,b)}{\partial a}$$</p><p>$$=\sum_{i=1}^{m}2(y^{i}-ax^{i}-b)(-x^{i})$$</p><p>$$=0$$</p><p>即</p><p>$$\sum_{i=1}^{m}(y^{i}-ax^{i}-b)(x^{i})=0$$</p><p>因为</p><p>$$b=\overline{y}-a\overline{x}$$</p><p>所以</p><p>$$\sum_{i=1}^{m}(y^{i}-ax^{i}-\overline{y}+a\overline{x})(x^{i})=0$$</p><p>$$\sum_{i=1}^{m}(y^{i}x^{i}-a(x^{i})^2-x^{i}\overline{y}+a\overline{x}x^{i})=0$$</p><p>$$\sum_{i=1}^{m}(y^{i}x^{i}-x^{i}\overline{y})-\sum_{i=1}^{m}(a(x^{i})^2-a\overline{x}x^{i})=0$$</p><p>$$\sum_{i=1}^{m}(y^{i}x^{i}-x^{i}\overline{y})= a\sum_{i=1}^{m}((x^{i})^2-\overline{x}x^{i})$$</p><p>所以</p><p>$$a=\frac{\sum_{i=1}^{m}(y^{i}x^{i}-x^{i}\overline{y})}{a\sum_{i=1}^{m}((x^{i})^2-\overline{x}x^{i})}$$</p><p>因为<br>$$\sum_{i=1}^{m}x^{i}\overline{y}=\overline{y}\sum_{i=1}^{m}x^{i}=m\overline{y}*\overline{x}$$</p><p>$$=\sum_{i=1}^{m}\overline{y}*\overline{x}= \overline{x}\sum_{i=1}^{m}y^{i}$$</p><p>所以</p><p>$$a=\frac{\sum_{i=1}^{m}(x^{i}y^{i}-x^{i}\overline{y}-\overline{x}y^{i}+\overline{x}*\overline{y})}{\sum_{i=1}^{m}((x^{i})^2-\overline{x}x^{i}-\overline{x}x^{i}+(\overline{x})^2)}$$</p><p>$$=\frac{\sum_{i=1}^{m}(x^{i}-\overline{x})(y^{i}-\overline{y})}{\sum_{i=1}^{m}(x^{i}-\overline{x})^2}$$</p><p>至此，我们已经得到了参数a、b的计算公式。</p><p>$$a=\frac{\sum_{i=1}^{m}(x^{i}-\overline{x})(y^{i}-\overline{y})}{\sum_{i=1}^{m}(x^{i}-\overline{x})^2}$$</p><p>$$b=\overline{y}-a\overline{x}$$</p><p>&ensp;&ensp;接下来我们就可以根据数据集对参数a、b进行训练，得到我们想要的那条直线。</p><p>&ensp;&ensp;当然，我们也不用非得自己编写这样一个线性回归算法，也有现成的API供我们调用，如scikit-learn中就已经包装了线性回归算法，调用起来也非常方便。但如果我们可以自己去写出这样一个线性回归算法时，我们对该算法的理解就会变得非常深。</p><p>&ensp;&ensp;加油吧！</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之knn</title>
      <link href="/2019/12/17/ji-qi-xue-xi-zhi-knn/"/>
      <url>/2019/12/17/ji-qi-xue-xi-zhi-knn/</url>
      
        <content type="html"><![CDATA[<h2 id="knn"><a href="#knn" class="headerlink" title="knn"></a>knn</h2><p>&ensp;&ensp;knn(k-nearest-neighbor)，顾名思义，就是k个距离最近的邻居，算法思想非常简单，可以用于解决分类问题。俗话说人以类聚，物以群分，如果我的邻居都喜欢安宁静谧的生活环境，那很大程度上我也是这样的人，否则我干嘛要跟他们做邻居呢？</p><p><a href="https://imgchr.com/i/QIdhBd" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/17/QIdhBd.md.jpg" alt="QIdhBd.md.jpg"></a></p><p>&ensp;&ensp;在这张图片中，当k=3时，我们会发现右上角的点距离最近的3个点都是蓝色，那么右上角的点则属于蓝色。</p><h2 id="距离怎么算？"><a href="#距离怎么算？" class="headerlink" title="距离怎么算？"></a>距离怎么算？</h2><p>&ensp;&ensp;在knn中，对于距离的定义各有不同，毕竟我们需要确定一种距离的计算方法，在高中我们都学习过欧拉距离公式，此外还有曼哈顿距离、明可夫斯基距离，当我们把这几个距离公式统一一下，就会发现他们的本质是一样的。</p><ul><li>欧拉距离<br>$$\sqrt{(x_1^a-x_1^b)^2+(x_2^a-x_2^b)^2+\cdots+(x_n^a-x_n^b)^2}$$<br>$$\sqrt{\sum_{i=1}^{n}(x_i^a-x_i^b)^2}$$<br>$$(\sum_{i=1}^{n}|x_{i}^a-x_{i}^b|^2)^{\frac{1}{2}}$$</li><li>曼哈顿距离<br>$$\sum_{i=1}^{n}|x_{i}^a-x_{i}^b|$$<br>$$(\sum_{i=1}^{n}|x_{i}^a-x_{i}^b|^2)^{\frac{1}{1}}$$</li><li>明可夫斯基距离<br>$$(\sum_{i=1}^{n}|x_{i}^a-x_{i}^b|^p)^{\frac{1}{p}}$$</li></ul><p>&ensp;&ensp;我们会发现，这三种距离公式的参数p是不同的，而这就是knn算法的一个超参数。</p><p>&ensp;&ensp;除了以上三种距离之外，还有很多的距离计算方法，如向量空间余弦相似度、调整余弦相似度、皮尔森相关系数、Jaccrard相似系数等。</p><h2 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h2><p>&ensp;&ensp;数据一般由于量纲的不同，在计算数据样本之间的距离时，很容易被其中某一种变量所主导，所以我们需要对数据做归一化处理，让数据样本中的变量处于同一量纲之下。</p><p>for example</p><table><thead><tr><th></th><th>肿瘤大小</th><th>发现时间</th></tr></thead><tbody><tr><td>样本1</td><td>1cm</td><td>200天</td></tr><tr><td>样本2</td><td>5cm</td><td>10天</td></tr></tbody></table><ul><li>最值归一化(normalization)<br>即把所有数据全部映射到0~1之间<br>$$<br>x_{scale} = \frac{x-x_{min}}{x_{max}-x_{min}}<br>$$</li><li>均值方差归一化(standardization)<br>即把所有数据全部映射到均值为0，方差为1的分布中<br>$$<br>x_{scale} = \frac{x-x_{mean}}{s}<br>$$<br>其中，分子上的为均值，分母上的为方差<br>&ensp;&ensp;我们要注意的是，当对测试数据集进行归一化时，要使用训练数据集的均值与方差，即<br>$$\frac{x_test-mean_{train}}{std_{train}}$$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础</title>
      <link href="/2019/12/17/shen-du-xue-xi-ji-chu/"/>
      <url>/2019/12/17/shen-du-xue-xi-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>&ensp;&ensp;在了解并学习机器学习时，我对深度学习这个词有非常大的疑惑，到底什么才是深度学习？深度学习到底有多深？这个问题非常可笑。后来我阅读了<a href="https://book.douban.com/subject/30293801/" target="_blank" rel="noopener">Python深度学习</a>这本书，这本书是由Keras之父François Chollet所写，对初学者比较友好，而且采用的是Keras框架，该框架基于Tensorflow，学习起来也不难。这本书我只读了一部分，整理笔记如下。</p><hr><p>1.张量</p><ul><li>ndim：轴/阶的个数</li><li>shape：形状</li><li>dtype：数据类型，unit8，float32，float64,char</li></ul><table><thead><tr><th>类型</th><th></th></tr></thead><tbody><tr><td>2维张量</td><td>样本轴、特征轴</td></tr><tr><td>3维张量(序列数据)</td><td>样本轴、时间轴、特征轴</td></tr><tr><td>4维张量(图像数据)</td><td>样本轴、高度轴、宽度轴、颜色深度轴</td></tr><tr><td>5维张量(视频数据)</td><td>样本轴、帧轴、高度轴、宽度轴、颜色深度轴</td></tr></tbody></table><p>2.层</p><table><thead><tr><th>张量</th><th>层</th><th>keras</th></tr></thead><tbody><tr><td>2维张量</td><td>dense layer(密集层)</td><td>keras的Dense类</td></tr><tr><td>3维张量(序列数据)</td><td>recurrent layer(循环层)</td><td>keras的LSTM层</td></tr><tr><td>4维张量(图像数据)</td><td>二维卷积层</td><td>keras的conv2D</td></tr></tbody></table><hr><p>神经网络的流程并不复杂，如下图所示<br><a href="https://imgchr.com/i/QICEiF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/17/QICEiF.md.jpg" alt="QICEiF.md.jpg"></a></p><hr><p>工作流程</p><ul><li><p>问题类型：二分类、多分类、标量回归、向量回归、聚类、强化学习</p></li><li><p>衡量指标：精度、准确率、召回率</p></li><li><p>评估方法：留出验证集、k折交叉验证、重复的k折验证</p></li><li><p>数据预处理<br>1 向量化：数据-&gt;张量<br>2 标准化：对每个特征分别标准化，使其均值为0，方差为1<br>3 处理缺失值：将缺失值设置为0<br>4 特征工程：对数据进行硬编码转换，以便于模型进行学习</p></li><li><p>构建模型</p></li></ul><table><thead><tr><th></th><th>最后一层激活</th><th>损失函数</th><th>优化器</th></tr></thead><tbody><tr><td>二分类</td><td>sigmoid</td><td>binary_crossentropy</td><td>rmsprop/默认的学习率</td></tr><tr><td>多分类单标签</td><td>softmax</td><td>categorical_crossentropy</td><td></td></tr><tr><td>多分类多标签</td><td>sigmoid</td><td>binary_crossentropy</td><td></td></tr><tr><td>回归到任意值</td><td>无</td><td>mse</td><td></td></tr><tr><td>回归到0~1</td><td>sigmoid</td><td>mse或binary_crossentropy</td><td></td></tr></tbody></table><ul><li>开发过拟合模型<br>1 添加更多的层<br>2 让每一层参数变多<br>3 训练更多的轮次<br>要始终监控训练损失和验证损失，以及训练指标值和验证指标值</li><li>模型正则化与调节超参数<br>1 添加dropout正则（在训练过程中随机将该层的一些输出特征设置为0）<br>2 添加权重正则化（强制让模型权重只能取较小的值。向网络损失函数中添加与较大权重值相关的成本）L1正则（添加的成本与权重系数的绝对值成正比）L2正则（添加的成本与权重系数的平方成正比）<br>3 增加或减少层数<br>4 尝试不同的超参数(每层的单元个数、优化器的学习率)<br>5 反复特征工程(添加新特征或删除没有信息量的特征</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neural network and deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维</title>
      <link href="/2019/12/16/si-wei/"/>
      <url>/2019/12/16/si-wei/</url>
      
        <content type="html"><![CDATA[<h1 id="转变看待世界的思维"><a href="#转变看待世界的思维" class="headerlink" title="转变看待世界的思维"></a>转变看待世界的思维</h1><p>&ensp;&ensp;这篇文章是关于郑路老师所讲的社会网络的课程的一些笔记整理以及所带来的一些启示，以此为记。若能带给你一些收获，那也是极好的。</p><p>&ensp;&ensp;在社会网络中有两个非常重要的概念，一是节点(node)，一是连接(tie),节点一般指行动者，如个人、群体、组织、城市、国家,连接反应的是节点间的互动关系。这是非常好理解的，就像在我们每个人都处在一个人际关系网中，每个独立的个体都是节点，我们与他人的关系就是一种连接。</p><p>&ensp;&ensp;郑路老师提到要用网络的视角看待这个世界，首先重视节点之间的相互影响。因为比起节点自身的特征或属性，节点之间的关系更加重要。其次，强调网络对节点的影响。再次，主张网络的结构特征，是我们理解现代社会生存和竞争的关键。</p><p>&ensp;&ensp;郑陆老师最后留下一道思考题，有什么现象，是个体视角无法理解，而一旦切换到网络的视角，就会得出全新的认识？对于这个问题，我想到的是当今学术界的论文发表现象，如果有两个水平相当的人文社科的研究生，他们花在学术上的时间是差不多的，一个人在一年之中发表了多篇C刊，而另一位则只发了一篇，如果从个体的视角去思考，那是想不通的，因为两个人水平相当，付出的精力也相当。但如果注意到这两位研究生的导师以及挂名的基金项目，就会发现，当学生处在不同的学术网络中，导师以及项目对学生的影响是不容小觑的。</p><h1 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h1><p>&ensp;&ensp;现实社会中存在更多的是动态、变化的事物，如各种网络中的节点之间的连接或者互动，之前听吴军老师在讲数学时，他曾提到为什么有的人在上大学之前数学学的都挺好的，上了大学之后数学反而学的不好了，那是因为学习数学的思维没有转化，初高中数学中的数字更多的是静态、直观的，而高等数学则需要从动态、规律性的视角去看待。</p>]]></content>
      
      
      <categories>
          
          <category> Society </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习之为什么要做笔记</title>
      <link href="/2019/12/16/ji-qi-xue-xi-zhi-wei-shi-me-zuo-bi-ji/"/>
      <url>/2019/12/16/ji-qi-xue-xi-zhi-wei-shi-me-zuo-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>&ensp;&ensp;我对机器学习是充满矛盾的，首先机器学习所能实现的功能是非常强大的，私底下也看了一些学习视频与书籍，但无奈学过之后没有实战之处，便搁置起来。学习过程中做的笔记七零八落，不成体系。</p><p>&ensp;&ensp;于己，不容易重新回顾，于他人，也没有带来任何帮助，便想通过Markdown来做笔记，上传到博客，一则方便自己回顾，二则如果能给各位客官带来一些帮助，那是再好不过了。</p><h1 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h1><p>&ensp;&ensp;机器学习实质上是要学习一个目标函数，能够尽可能的还原输入与输出之间的关系，在学习过程中不断缩小误差，确定函数的系数。如果得到了目标函数，我们就可以根据新的自变量x，预测因变量y。</p><p><a href="https://imgchr.com/i/QIlAnf" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/17/QIlAnf.md.jpg" alt="QIlAnf.md.jpg"></a></p><p>&ensp;&ensp;其中我们首先要明确两种参数，超参数，算法运行前要决定的参数，模型参数，算法过程中学习的参数。参数选的好，算法差不了！</p><p>&ensp;&ensp;在评价机器学习算法好坏时，有多种评价方法</p><ul><li>分类准确度 <pre class="line-numbers language-python"><code class="language-python">np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>y_predict<span class="token operator">==</span>y_test<span class="token punctuation">)</span><span class="token operator">/</span>len<span class="token punctuation">(</span>y_test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>&ensp;&ensp;机器学习的算法非常之多，并没有一种万能的算法能够解决任何的问题。因此，我会逐一整理几个非常重要的机器学习算法，有knn、线性回归、逻辑回归、SVM、决策树、集成学习、随机森林。毕竟能够使用才是最重要的。学习是无止境的，但进一寸便有一寸的欣喜。我是个小白，希望能够不断进步。</p><h2 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h2>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节点</title>
      <link href="/2019/11/28/jie-dian/"/>
      <url>/2019/11/28/jie-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="中心度"><a href="#中心度" class="headerlink" title="中心度"></a>中心度</h1><p>&ensp;&ensp;郑路老师在”节点”这一单元提到了一个非常重要的概念-中心度(centrality)，它可以用来测量节点在网络中的重要程度。它有三个维度，即度中心度（Degree Centrality）,中介中心度(Betweenness Centrality)，特征向量中心度(Eigenvector Centrality)</p><p>&ensp;&ensp;度中心度说的通俗一点就是我的邻居的数量，我的邻居越多，我的影响力越大。中介中心度就是网络中我可以作为中间人的数量，越多的人依赖我，我越重要。而特征向量中心度则是我的邻居的质量，我的邻居影响力越大，我的影响力越大，是不是很简单。想一想，如果我的朋友都是商界大佬，政界大亨，那我所调动的资源则不容小觑。</p><p>&ensp;&ensp;衡量个体在网络中的重要性需要依据不同的需求调整在不同维度上的侧重点。</p>]]></content>
      
      
      <categories>
          
          <category> Society </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
